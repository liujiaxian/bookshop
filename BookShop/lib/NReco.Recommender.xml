<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NReco.Recommender</name>
    </assembly>
    <members>
        <member name="T:NReco.Math3.Distribution.AbstractIntegerDistribution">
             Base class for integer-valued discrete distributions.  Default
             implementations are provided for some of the methods that do not vary
             from distribution to distribution.
            
             @version $Id: AbstractIntegerDistribution.java 1547633 2013-12-03 23:03:06Z tn $
        </member>
        <member name="F:NReco.Math3.Distribution.AbstractIntegerDistribution.random">
            RNG instance used to generate samples from the distribution.
            @since 3.1
        </member>
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.#ctor(NReco.Math3.Random.IRandomGenerator)">
            @param rng Random number generator.
            @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Distribution.AbstractIntegerDistribution.cumulativeProbability(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Distribution.AbstractIntegerDistribution.inverseCumulativeProbability(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability(System.Double,System.Int32,System.Int32)" -->
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.reseedRandomGenerator(System.Int64)">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.sample">
             {@inheritDoc}
            
             The default implementation uses the
             <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling">
             inversion method</a>.
        </member>
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.sample(System.Int32)">
             {@inheritDoc}
            
             The default implementation generates the sample by calling
             {@link #sample()} in a loop.
        </member>
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.checkedCumulativeProbability(System.Int32)">
             Computes the cumulative probability function and checks for {@code NaN}
             values returned. Throws {@code MathInternalError} if the value is
             {@code NaN}. Rethrows any exception encountered evaluating the cumulative
             probability function. Throws {@code MathInternalError} if the cumulative
             probability function returns {@code NaN}.
            
             @param argument input value
             @return the cumulative probability
             @{@code NaN}
        </member>
        <member name="M:NReco.Math3.Distribution.AbstractIntegerDistribution.logProbability(System.Int32)">
             For a random variable {@code X} whose values are distributed according to
             this distribution, this method returns {@code log(P(X = x))}, where
             {@code log} is the natural logarithm. In other words, this method
             represents the logarithm of the probability mass function (PMF) for the
             distribution. Note that due to the floating point precision and
             under/overflow issues, this method will for some distributions be more
             precise and faster than computing the logarithm of
             {@link #probability(int)}.
             <p>
             The default implementation simply computes the logarithm of {@code probability(x)}.</p>
            
             @param x the point at which the PMF is evaluated
             @return the logarithm of the value of the probability mass function at {@code x}
        </member>
        <member name="T:NReco.Math3.Als.AlternatingLeastSquaresSolver">
            See
            <a href="http://www.hpl.hp.com/personal/Robert_Schreiber/papers/2008%20AAIM%20Netflix/netflix_aaim08(submitted).pdf">
            this paper.</a>
        </member>
        <member name="T:NReco.Math3.Special.Beta">
             <p>
             This is a utility class that provides computation methods related to the
             Beta family of functions.
             </p>
             <p>
             Implementation of {@link #logBeta(double, double)} is based on the
             algorithms described in
             <ul>
             <li><a href="http://dx.doi.org/10.1145/22721.23109">Didonato and Morris
                 (1986)</a>, <em>Computation of the Incomplete Gamma Function Ratios
                 and their Inverse</em>, TOMS 12(4), 377-393,</li>
             <li><a href="http://dx.doi.org/10.1145/131766.131776">Didonato and Morris
                 (1992)</a>, <em>Algorithm 708: Significant Digit Computation of the
                 Incomplete Beta Function Ratios</em>, TOMS 18(3), 360-373,</li>
             </ul>
             and implemented in the
             <a href="http://www.dtic.mil/docs/citations/ADA476840">NSWC Library of Mathematical Functions</a>,
             available
             <a href="http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html">here</a>.
             This library is "approved for public release", and the
             <a href="http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf">Copyright guidance</a>
             indicates that unless otherwise stated in the code, all FORTRAN functions in
             this library are license free. Since no such notice appears in the code these
             functions can safely be ported to Commons-Math.
             </p>
            
            
             @version $Id: Beta.java 1546350 2013-11-28 11:41:12Z erans $
        </member>
        <member name="F:NReco.Math3.Special.Beta.DEFAULT_EPSILON">
            Maximum allowed numerical error. */
        </member>
        <member name="F:NReco.Math3.Special.Beta.HALF_LOG_TWO_PI">
            The constant value of ½log 2π. */
        </member>
        <!-- Badly formed XML comment ignored for member "F:NReco.Math3.Special.Beta.DELTA" -->
        <member name="M:NReco.Math3.Special.Beta.#ctor">
            Default constructor.  Prohibit instantiation.
        </member>
        <member name="M:NReco.Math3.Special.Beta.regularizedBeta(System.Double,System.Double,System.Double)">
             Returns the
             <a href="http://mathworld.wolfram.com/RegularizedBetaFunction.html">
             regularized beta function</a> I(x, a, b).
            
             @param x Value.
             @param a Parameter {@code a}.
             @param b Parameter {@code b}.
             @return the regularized beta function I(x, a, b).
             @throws NReco.Math3.Exception.MaxCountExceededException
             if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Beta.regularizedBeta(System.Double,System.Double,System.Double,System.Double)">
             Returns the
             <a href="http://mathworld.wolfram.com/RegularizedBetaFunction.html">
             regularized beta function</a> I(x, a, b).
            
             @param x Value.
             @param a Parameter {@code a}.
             @param b Parameter {@code b}.
             @param epsilon When the absolute value of the nth item in the
             series is less than epsilon the approximation ceases to calculate
             further elements in the series.
             @return the regularized beta function I(x, a, b)
             @throws NReco.Math3.Exception.MaxCountExceededException
             if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Beta.regularizedBeta(System.Double,System.Double,System.Double,System.Int32)">
             Returns the regularized beta function I(x, a, b).
            
             @param x the value.
             @param a Parameter {@code a}.
             @param b Parameter {@code b}.
             @param maxIterations Maximum number of "iterations" to complete.
             @return the regularized beta function I(x, a, b)
             @throws NReco.Math3.Exception.MaxCountExceededException
             if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Beta.regularizedBeta(System.Double,System.Double,System.Double,System.Double,System.Int32)">
             Returns the regularized beta function I(x, a, b).
            
             The implementation of this method is based on:
             <ul>
             <li>
             <a href="http://mathworld.wolfram.com/RegularizedBetaFunction.html">
             Regularized Beta Function</a>.</li>
             <li>
             <a href="http://functions.wolfram.com/06.21.10.0001.01">
             Regularized Beta Function</a>.</li>
             </ul>
            
             @param x the value.
             @param a Parameter {@code a}.
             @param b Parameter {@code b}.
             @param epsilon When the absolute value of the nth item in the
             series is less than epsilon the approximation ceases to calculate
             further elements in the series.
             @param maxIterations Maximum number of "iterations" to complete.
             @return the regularized beta function I(x, a, b)
             @throws NReco.Math3.Exception.MaxCountExceededException
             if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Beta.logBeta(System.Double,System.Double,System.Double,System.Int32)">
             Returns the natural logarithm of the beta function B(a, b).
            
             The implementation of this method is based on:
             <ul>
             <li><a href="http://mathworld.wolfram.com/BetaFunction.html">
             Beta Function</a>, equation (1).</li>
             </ul>
            
             @param a Parameter {@code a}.
             @param b Parameter {@code b}.
             @param epsilon This parameter is ignored.
             @param maxIterations This parameter is ignored.
             @return log(B(a, b)).
             @deprecated as of version 3.1, this method is deprecated as the
             computation of the beta function is no longer iterative; it will be
             removed in version 4.0. Current implementation of this method
             internally calls {@link #logBeta(double, double)}.
        </member>
        <member name="M:NReco.Math3.Special.Beta.logGammaSum(System.Double,System.Double)">
             Returns the value of log Γ(a + b) for 1 ≤ a, b ≤ 2. Based on the
             <em>NSWC Library of Mathematics Subroutines</em> double precision
             implementation, {@code DGSMLN}. In {@code BetaTest.testLogGammaSum()},
             this private method is accessed through reflection.
            
             @param a First argument.
             @param b Second argument.
             @return the value of {@code log(Gamma(a + b))}.
             @{@code a} or {@code b} is lower than
             {@code 1.0} or greater than {@code 2.0}.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Beta.logGammaMinusLogGammaSum(System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Beta.deltaMinusDeltaSum(System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Beta.sumDeltaMinusDeltaSum(System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Beta.logBeta(System.Double,System.Double)" -->
        <member name="T:NReco.Math3.Util.ContinuedFraction">
             Provides a generic means to evaluate continued fractions.  Subclasses simply
             provided the a and b coefficients to evaluate the continued fraction.
            
             <p>
             References:
             <ul>
             <li><a href="http://mathworld.wolfram.com/ContinuedFraction.html">
             Continued Fraction</a></li>
             </ul>
             </p>
            
             @version $Id: ContinuedFraction.java 1416643 2012-12-03 19:37:14Z tn $
        </member>
        <member name="F:NReco.Math3.Util.ContinuedFraction.DEFAULT_EPSILON">
            Maximum allowed numerical error. */
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.#ctor">
            Default constructor.
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.getA(System.Int32,System.Double)">
            Access the n-th a coefficient of the continued fraction.  Since a can be
            a function of the evaluation point, x, that is passed in as well.
            @param n the coefficient index to retrieve.
            @param x the evaluation point.
            @return the n-th a coefficient.
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.getB(System.Int32,System.Double)">
            Access the n-th b coefficient of the continued fraction.  Since b can be
            a function of the evaluation point, x, that is passed in as well.
            @param n the coefficient index to retrieve.
            @param x the evaluation point.
            @return the n-th b coefficient.
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.evaluate(System.Double)">
            Evaluates the continued fraction at the value x.
            @param x the evaluation point.
            @return the value of the continued fraction evaluated at x.
            @throws ConvergenceException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.evaluate(System.Double,System.Double)">
            Evaluates the continued fraction at the value x.
            @param x the evaluation point.
            @param epsilon maximum error allowed.
            @return the value of the continued fraction evaluated at x.
            @throws ConvergenceException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.evaluate(System.Double,System.Int32)">
            Evaluates the continued fraction at the value x.
            @param x the evaluation point.
            @param maxIterations maximum number of convergents
            @return the value of the continued fraction evaluated at x.
            @throws ConvergenceException if the algorithm fails to converge.
            @throws MaxCountExceededException if maximal number of iterations is reached
        </member>
        <member name="M:NReco.Math3.Util.ContinuedFraction.evaluate(System.Double,System.Double,System.Int32)">
             Evaluates the continued fraction at the value x.
             <p>
             The implementation of this method is based on the modified Lentz algorithm as described
             on page 18 ff. in:
             <ul>
               <li>
               I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order."
               <a target="_blank" href="http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">
               http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>
               </li>
             </ul>
             <b>Note:</b> the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in
             <a href="http://mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction @ MathWorld</a>.
             </p>
            
             @param x the evaluation point.
             @param epsilon maximum error allowed.
             @param maxIterations maximum number of convergents
             @return the value of the continued fraction evaluated at x.
             @throws ConvergenceException if the algorithm fails to converge.
             @throws MaxCountExceededException if maximal number of iterations is reached
        </member>
        <member name="T:NReco.Math3.Random.BitsStreamGenerator">
             Base class for random number generators that generates bits streams.
            
             @version $Id: BitsStreamGenerator.java 1538368 2013-11-03 13:57:37Z erans $
             @since 2.0
        </member>
        <member name="T:NReco.Math3.Random.IRandomGenerator">
             Interface extracted from <code>java.util.Random</code>.  This interface is
             implemented by {@link AbstractRandomGenerator}.
            
             @since 1.1
             @version $Id: RandomGenerator.java 1416643 2012-12-03 19:37:14Z tn $
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.setSeed(System.Int32)">
            Sets the seed of the underlying random number generator using an
            <code>int</code> seed.
            <p>Sequences of values generated starting with the same seeds
            should be identical.
            </p>
            @param seed the seed value
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.setSeed(System.Int32[])">
            Sets the seed of the underlying random number generator using an
            <code>int</code> array seed.
            <p>Sequences of values generated starting with the same seeds
            should be identical.
            </p>
            @param seed the seed value
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.setSeed(System.Int64)">
            Sets the seed of the underlying random number generator using a
            <code>long</code> seed.
            <p>Sequences of values generated starting with the same seeds
            should be identical.
            </p>
            @param seed the seed value
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextBytes(System.Byte[])">
             Generates random bytes and places them into a user-supplied
             byte array.  The number of random bytes produced is equal to
             the length of the byte array.
            
             @param bytes the non-null byte array in which to put the
             random bytes
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextInt">
             Returns the next pseudorandom, uniformly distributed <code>int</code>
             value from this random number generator's sequence.
             All 2<font size="-1"><sup>32</sup></font> possible <tt>int</tt> values
             should be produced with  (approximately) equal probability.
            
             @return the next pseudorandom, uniformly distributed <code>int</code>
              value from this random number generator's sequence
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextInt(System.Int32)">
             Returns a pseudorandom, uniformly distributed <tt>int</tt> value
             between 0 (inclusive) and the specified value (exclusive), drawn from
             this random number generator's sequence.
            
             @param n the bound on the random number to be returned.  Must be
             positive.
             @return  a pseudorandom, uniformly distributed <tt>int</tt>
             value between 0 (inclusive) and n (exclusive).
             @throws IllegalArgumentException  if n is not positive.
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextlong">
             Returns the next pseudorandom, uniformly distributed <code>long</code>
             value from this random number generator's sequence.  All
             2<font size="-1"><sup>64</sup></font> possible <tt>long</tt> values
             should be produced with (approximately) equal probability.
            
             @return  the next pseudorandom, uniformly distributed <code>long</code>
            value from this random number generator's sequence
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextBoolean">
             Returns the next pseudorandom, uniformly distributed
             <code>bool</code> value from this random number generator's
             sequence.
            
             @return  the next pseudorandom, uniformly distributed
             <code>bool</code> value from this random number generator's
             sequence
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextFloat">
             Returns the next pseudorandom, uniformly distributed <code>float</code>
             value between <code>0.0</code> and <code>1.0</code> from this random
             number generator's sequence.
            
             @return  the next pseudorandom, uniformly distributed <code>float</code>
             value between <code>0.0</code> and <code>1.0</code> from this
             random number generator's sequence
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextDouble">
             Returns the next pseudorandom, uniformly distributed
             <code>double</code> value between <code>0.0</code> and
             <code>1.0</code> from this random number generator's sequence.
            
             @return  the next pseudorandom, uniformly distributed
              <code>double</code> value between <code>0.0</code> and
              <code>1.0</code> from this random number generator's sequence
        </member>
        <member name="M:NReco.Math3.Random.IRandomGenerator.nextGaussian">
             Returns the next pseudorandom, Gaussian ("normally") distributed
             <code>double</code> value with mean <code>0.0</code> and standard
             deviation <code>1.0</code> from this random number generator's sequence.
            
             @return  the next pseudorandom, Gaussian ("normally") distributed
             <code>double</code> value with mean <code>0.0</code> and
             standard deviation <code>1.0</code> from this random number
              generator's sequence
        </member>
        <member name="F:NReco.Math3.Random.BitsStreamGenerator.serialVersionUID">
            Serializable version identifier */
        </member>
        <member name="F:NReco.Math3.Random.BitsStreamGenerator._nextGaussian">
            Next gaussian. */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.#ctor">
            Creates a new random number generator.
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.setSeed(System.Int32)">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.setSeed(System.Int32[])">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.setSeed(System.Int64)">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.next(System.Int32)">
            Generate next pseudorandom number.
            <p>This method is the core generation algorithm. It is used by all the
            public generation methods for the various primitive types {@link
            #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},
            {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},
            {@link #next(int)} and {@link #nextlong()}.</p>
            @param bits number of random bits to produce
            @return random bits generated
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextBoolean">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextBytes(System.Byte[])">
            {@inheritDoc} */
        </member>
        <member name="F:NReco.Math3.Random.BitsStreamGenerator.minNonZeroDouble">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextFloat">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextGaussian">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextInt">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextInt(System.Int32)">
             {@inheritDoc}
             <p>This default implementation is copied from Apache Harmony
             java.util.Random (r929253).</p>
            
             <p>Implementation notes: <ul>
             <li>If n is a power of 2, this method returns
             {@code (int) ((n * (long) next(31)) >> 31)}.</li>
            
             <li>If n is not a power of 2, what is returned is {@code next(31) % n}
             with {@code next(31)} values rejected (i.e. regenerated) until a
             value that is larger than the remainder of {@code Integer.MAX_VALUE / n}
             is generated. Rejection of this initial segment is necessary to ensure
             a uniform distribution.</li></ul></p>
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextlong">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.nextlong(System.Int64)">
             Returns a pseudorandom, uniformly distributed <tt>long</tt> value
             between 0 (inclusive) and the specified value (exclusive), drawn from
             this random number generator's sequence.
            
             @param n the bound on the random number to be returned.  Must be
             positive.
             @return  a pseudorandom, uniformly distributed <tt>long</tt>
             value between 0 (inclusive) and n (exclusive).
             @throws IllegalArgumentException  if n is not positive.
        </member>
        <member name="M:NReco.Math3.Random.BitsStreamGenerator.clear">
            Clears the cache used by the default implementation of
            {@link #nextGaussian}.
        </member>
        <!-- Badly formed XML comment ignored for member "T:NReco.Math3.Special.Gamma" -->
        <member name="F:NReco.Math3.Special.Gamma.GAMMA">
            <a href="http://en.wikipedia.org/wiki/Euler-Mascheroni_constant">Euler-Mascheroni constant</a>
            @since 2.0
        </member>
        <member name="F:NReco.Math3.Special.Gamma.LANCZOS_G">
            The value of the {@code g} constant in the Lanczos approximation, see
            {@link #lanczos(double)}.
            @since 3.1
        </member>
        <member name="F:NReco.Math3.Special.Gamma.DEFAULT_EPSILON">
            Maximum allowed numerical error. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.LANCZOS">
            Lanczos coefficients */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.HALF_LOG_2_PI">
            Avoid repeated computation of log of 2 PI in logGamma */
        </member>
        <!-- Badly formed XML comment ignored for member "F:NReco.Math3.Special.Gamma.SQRT_TWO_PI" -->
        <member name="F:NReco.Math3.Special.Gamma.C_LIMIT">
            C limit. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.S_LIMIT">
            S limit. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_A0">
            The constant {@code A0} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_A1">
            The constant {@code A1} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B1">
            The constant {@code B1} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B2">
            The constant {@code B2} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B3">
            The constant {@code B3} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B4">
            The constant {@code B4} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B5">
            The constant {@code B5} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B6">
            The constant {@code B6} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B7">
            The constant {@code B7} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_B8">
            The constant {@code B8} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P0">
            The constant {@code P0} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P1">
            The constant {@code P1} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P2">
            The constant {@code P2} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P3">
            The constant {@code P3} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P4">
            The constant {@code P4} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P5">
            The constant {@code P5} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_P6">
            The constant {@code P6} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_Q1">
            The constant {@code Q1} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_Q2">
            The constant {@code Q2} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_Q3">
            The constant {@code Q3} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_Q4">
            The constant {@code Q4} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C">
            The constant {@code C} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C0">
            The constant {@code C0} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C1">
            The constant {@code C1} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C2">
            The constant {@code C2} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C3">
            The constant {@code C3} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C4">
            The constant {@code C4} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C5">
            The constant {@code C5} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C6">
            The constant {@code C6} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C7">
            The constant {@code C7} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C8">
            The constant {@code C8} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C9">
            The constant {@code C9} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C10">
            The constant {@code C10} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C11">
            The constant {@code C11} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C12">
            The constant {@code C12} defined in {@code DGAM1}. */
        </member>
        <member name="F:NReco.Math3.Special.Gamma.INV_GAMMA1P_M1_C13">
            The constant {@code C13} defined in {@code DGAM1}. */
        </member>
        <member name="M:NReco.Math3.Special.Gamma.#ctor">
            Default constructor.  Prohibit instantiation.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Gamma.logGamma(System.Double)" -->
        <member name="M:NReco.Math3.Special.Gamma.regularizedGammaP(System.Double,System.Double)">
             Returns the regularized gamma function P(a, x).
            
             @param a Parameter.
             @param x Value.
             @return the regularized gamma function P(a, x).
             @throws MaxCountExceededException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Gamma.regularizedGammaP(System.Double,System.Double,System.Double,System.Int32)">
             Returns the regularized gamma function P(a, x).
            
             The implementation of this method is based on:
             <ul>
              <li>
               <a href="http://mathworld.wolfram.com/RegularizedGammaFunction.html">
               Regularized Gamma Function</a>, equation (1)
              </li>
              <li>
               <a href="http://mathworld.wolfram.com/IncompleteGammaFunction.html">
               Incomplete Gamma Function</a>, equation (4).
              </li>
              <li>
               <a href="http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html">
               Confluent Hypergeometric Function of the First Kind</a>, equation (1).
              </li>
             </ul>
            
             @param a the a parameter.
             @param x the value.
             @param epsilon When the absolute value of the nth item in the
             series is less than epsilon the approximation ceases to calculate
             further elements in the series.
             @param maxIterations Maximum number of "iterations" to complete.
             @return the regularized gamma function P(a, x)
             @throws MaxCountExceededException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Gamma.regularizedGammaQ(System.Double,System.Double)">
             Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
            
             @param a the a parameter.
             @param x the value.
             @return the regularized gamma function Q(a, x)
             @throws MaxCountExceededException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Gamma.regularizedGammaQ(System.Double,System.Double,System.Double,System.Int32)">
             Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
            
             The implementation of this method is based on:
             <ul>
              <li>
               <a href="http://mathworld.wolfram.com/RegularizedGammaFunction.html">
               Regularized Gamma Function</a>, equation (1).
              </li>
              <li>
               <a href="http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/">
               Regularized incomplete gamma function: Continued fraction representations
               (formula 06.08.10.0003)</a>
              </li>
             </ul>
            
             @param a the a parameter.
             @param x the value.
             @param epsilon When the absolute value of the nth item in the
             series is less than epsilon the approximation ceases to calculate
             further elements in the series.
             @param maxIterations Maximum number of "iterations" to complete.
             @return the regularized gamma function P(a, x)
             @throws MaxCountExceededException if the algorithm fails to converge.
        </member>
        <member name="M:NReco.Math3.Special.Gamma.digamma(System.Double)">
             <p>Computes the digamma function of x.</p>
            
             <p>This is an independently written implementation of the algorithm described in
             Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>
            
             <p>Some of the constants have been changed to increase accuracy at the moderate expense
             of run-time.  The result should be accurate to within 10^-8 absolute tolerance for
             x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>
            
             <p>Performance for large negative values of x will be quite expensive (proportional to
             |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results
             less than 10^5 and 10^-8 relative for results larger than that.</p>
            
             @param x Argument.
             @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.
             @see <a href="http://en.wikipedia.org/wiki/Digamma_function">Digamma</a>
             @see <a href="http://www.uv.es/~bernardo/1976AppStatist.pdf">Bernardo&apos;s original article </a>
             @since 2.0
        </member>
        <member name="M:NReco.Math3.Special.Gamma.trigamma(System.Double)">
             Computes the trigamma function of x.
             This function is derived by taking the derivative of the implementation
             of digamma.
            
             @param x Argument.
             @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller
             @see <a href="http://en.wikipedia.org/wiki/Trigamma_function">Trigamma</a>
             @see Gamma#digamma(double)
             @since 2.0
        </member>
        <member name="M:NReco.Math3.Special.Gamma.lanczos(System.Double)">
             <p>
             Returns the Lanczos approximation used to compute the gamma function.
             The Lanczos approximation is related to the Gamma function by the
             following equation
             <center>
             {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)
                               * exp(-x - g - 0.5) * lanczos(x)},
             </center>
             where {@code g} is the Lanczos constant.
             </p>
            
             @param x Argument.
             @return The Lanczos approximation.
             @see <a href="http://mathworld.wolfram.com/LanczosApproximation.html">Lanczos Approximation</a>
             equations (1) through (5), and Paul Godfrey's
             <a href="http://my.fit.edu/~gabdo/gamma.txt">Note on the computation
             of the convergent Lanczos complex Gamma approximation</a>
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Gamma.invGamma1pm1(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Gamma.logGamma1p(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Special.Gamma.rint(System.Double)" -->
        <member name="M:NReco.Math3.Special.Gamma.gamma(System.Double)">
             Returns the value of Γ(x). Based on the <em>NSWC Library of
             Mathematics Subroutines</em> double precision implementation,
             {@code DGAMMA}.
            
             @param x Argument.
             @return the value of {@code Gamma(x)}.
             @since 3.1
        </member>
        <member name="T:NReco.Math3.Als.ImplicitFeedbackAlternatingLeastSquaresSolver">
            see <a href="http://research.yahoo.com/pub/2433">Collaborative Filtering for Implicit Feedback Datasets</a> 
        </member>
        <member name="M:NReco.Math3.Als.ImplicitFeedbackAlternatingLeastSquaresSolver.getYtransposeY(System.Collections.Generic.IDictionary{System.Int32,System.Double[]})">
            Y' Y 
        </member>
        <member name="M:NReco.Math3.Als.ImplicitFeedbackAlternatingLeastSquaresSolver.getYtransponseCuMinusIYPlusLambdaI(System.Collections.Generic.IList{System.Tuple{System.Int32,System.Double}})">
            Y' (Cu - I) Y + λ I 
        </member>
        <member name="M:NReco.Math3.Als.ImplicitFeedbackAlternatingLeastSquaresSolver.getYtransponseCuPu(System.Collections.Generic.IList{System.Tuple{System.Int32,System.Double}})">
            Y' Cu p(u) 
        </member>
        <member name="T:NReco.Math3.Stats.LogLikelihood">
            Utility methods for working with log-likelihood
        </member>
        <member name="M:NReco.Math3.Stats.LogLikelihood.entropy(System.Int64[])">
             Calculates the unnormalized Shannon entropy.  This is
            
             -sum x_i log x_i / N = -N sum x_i/N log x_i/N
            
             where N = sum x_i
            
             If the x's sum to 1, then this is the same as the normal
             expression.  Leaving this un-normalized makes working with
             counts and computing the LLR easier.
            
             @return The entropy value for the elements
        </member>
        <member name="M:NReco.Math3.Stats.LogLikelihood.entropy(System.Int64,System.Int64)">
            Merely an optimization for the common two argument case of {@link #entropy(long...)}
            @see #logLikelihoodRatio(long, long, long, long)
        </member>
        <member name="M:NReco.Math3.Stats.LogLikelihood.entropy(System.Int64,System.Int64,System.Int64,System.Int64)">
            Merely an optimization for the common four argument case of {@link #entropy(long...)}
            @see #logLikelihoodRatio(long, long, long, long)
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Stats.LogLikelihood.logLikelihoodRatio(System.Int64,System.Int64,System.Int64,System.Int64)" -->
        <member name="M:NReco.Math3.Stats.LogLikelihood.rootLogLikelihoodRatio(System.Int64,System.Int64,System.Int64,System.Int64)">
             @param k11 The number of times the two events occurred together
             @param k12 The number of times the second event occurred WITHOUT the first event
             @param k21 The number of times the first event occurred WITHOUT the second event
             @param k22 The number of times something else occurred (i.e. was neither of these events
             @return The root log-likelihood ratio
             
             <p/>
             There is some more discussion here: http://s.apache.org/CGL
            
             And see the response to Wataru's comment here:
             http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html
        </member>
        <member name="F:NReco.Math3.Util.MathUtil.TWO_POWER_52">
            2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite 
        </member>
        <!-- Badly formed XML comment ignored for member "F:NReco.Math3.Util.MathUtil.LN_QUICK_COEF" -->
        <member name="F:NReco.Math3.Util.MathUtil.LN_2_A">
            log(2) (high bits). 
        </member>
        <member name="F:NReco.Math3.Util.MathUtil.LN_2_B">
            log(2) (low bits). 
        </member>
        <member name="M:NReco.Math3.Util.MathUtil.Log(System.Double)">
             Natural logarithm.
            
             @param x   a double
             @return log(x)
        </member>
        <member name="M:NReco.Math3.Util.MathUtil.Log(System.Double,System.Double[])">
            Internal helper method for natural logarithm function.
            @param x original argument of the natural logarithm function
            @param hiPrec extra bits of precision on output (To Be Confirmed)
            @return log(x)
        </member>
        <member name="T:NReco.Math3.Util.MathUtil.lnMant">
            Enclose large data table in nested static class so it's only loaded on first access. 
        </member>
        <member name="F:NReco.Math3.Util.MathUtil.lnMant.LN_MANT">
            Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. 
        </member>
        <member name="T:NReco.Math3.Random.MersenneTwister">
            @version $Id: MersenneTwister.java 1416643 2012-12-03 19:37:14Z tn $
            @since 2.0
        </member>
        <member name="F:NReco.Math3.Random.MersenneTwister.N">
            Size of the bytes pool. */
        </member>
        <member name="F:NReco.Math3.Random.MersenneTwister.M">
            Period second parameter. */
        </member>
        <member name="F:NReco.Math3.Random.MersenneTwister.MAG01">
            X * MATRIX_A for X = {0, 1}. */
        </member>
        <member name="F:NReco.Math3.Random.MersenneTwister.mt">
            Bytes pool. */
        </member>
        <member name="F:NReco.Math3.Random.MersenneTwister.mti">
            Current index in the bytes pool. */
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.#ctor">
            Creates a new random number generator.
            <p>The instance is initialized using the current time plus the
            system identity hash code of this instance as the seed.</p>
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.#ctor(System.Int32)">
            Creates a new random number generator using a single int seed.
            @param seed the initial seed (32 bits integer)
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.#ctor(System.Int32[])">
            Creates a new random number generator using an int array seed.
            @param seed the initial seed (32 bits integers array), if null
            the seed of the generator will be related to the current time
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.#ctor(System.Int64)">
            Creates a new random number generator using a single long seed.
            @param seed the initial seed (64 bits integer)
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.setSeed(System.Int32)">
            Reinitialize the generator as if just built with the given int seed.
            <p>The state of the generator is exactly the same as a new
            generator built with the same seed.</p>
            @param seed the initial seed (32 bits integer)
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.setSeed(System.Int32[])">
            Reinitialize the generator as if just built with the given int array seed.
            <p>The state of the generator is exactly the same as a new
            generator built with the same seed.</p>
            @param seed the initial seed (32 bits integers array), if null
            the seed of the generator will be the current system time plus the
            system identity hash code of this instance
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.setSeed(System.Int64)">
            Reinitialize the generator as if just built with the given long seed.
            <p>The state of the generator is exactly the same as a new
            generator built with the same seed.</p>
            @param seed the initial seed (64 bits integer)
        </member>
        <member name="M:NReco.Math3.Random.MersenneTwister.next(System.Int32)">
            Generate next pseudorandom number.
            <p>This method is the core generation algorithm. It is used by all the
            public generation methods for the various primitive types {@link
            #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},
            {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},
            {@link #next(int)} and {@link #nextlong()}.</p>
            @param bits number of random bits to produce
            @return random bits generated
        </member>
        <member name="T:NReco.Math3.Exception.NotStrictlyPositiveException">
             Exception to be thrown when the argument is not greater than 0.
            
             @since 2.2
             @version $Id: NotStrictlyPositiveException.java 1533795 2013-10-19 17:27:34Z psteitz $
        </member>
        <!-- Badly formed XML comment ignored for member "T:NReco.Math3.Distribution.PascalDistribution" -->
        <member name="F:NReco.Math3.Distribution.PascalDistribution.serialVersionUID">
            Serializable version identifier. */
        </member>
        <member name="F:NReco.Math3.Distribution.PascalDistribution.numberOfSuccesses">
            The number of successes. */
        </member>
        <member name="F:NReco.Math3.Distribution.PascalDistribution.probabilityOfSuccess">
            The probability of success. */
        </member>
        <member name="F:NReco.Math3.Distribution.PascalDistribution.logProbabilityOfSuccess">
            The value of {@code log(p)}, where {@code p} is the probability of success,
            stored for faster computation. */
        </member>
        <member name="F:NReco.Math3.Distribution.PascalDistribution.log1mProbabilityOfSuccess">
            The value of {@code log(1-p)}, where {@code p} is the probability of success,
            stored for faster computation. */
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.#ctor(System.Int32,System.Double)">
             Create a Pascal distribution with the given number of successes and
             probability of success.
            
             @param r Number of successes.
             @param p Probability of success.
             @throws NotStrictlyPositiveException if the number of successes is not positive
             @throws OutOfRangeException if the probability of success is not in the
             range {@code [0, 1]}.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.#ctor(NReco.Math3.Random.IRandomGenerator,System.Int32,System.Double)">
             Create a Pascal distribution with the given number of successes and
             probability of success.
            
             @param rng Random number generator.
             @param r Number of successes.
             @param p Probability of success.
             @throws NotStrictlyPositiveException if the number of successes is not positive
             @throws OutOfRangeException if the probability of success is not in the
             range {@code [0, 1]}.
             @since 3.1
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getNumberOfSuccesses">
             Access the number of successes for this distribution.
            
             @return the number of successes.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getProbabilityOfSuccess">
             Access the probability of success for this distribution.
            
             @return the probability of success.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.probability(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.logProbability(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.cumulativeProbability(System.Int32)">
            {@inheritDoc} */
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getNumericalMean">
             {@inheritDoc}
            
             For number of successes {@code r} and probability of success {@code p},
             the mean is {@code r * (1 - p) / p}.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getNumericalVariance">
             {@inheritDoc}
            
             For number of successes {@code r} and probability of success {@code p},
             the variance is {@code r * (1 - p) / p^2}.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getSupportLowerBound">
             {@inheritDoc}
            
             The lower bound of the support is always 0 no matter the parameters.
            
             @return lower bound of the support (always 0)
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.getSupportUpperBound">
             {@inheritDoc}
            
             The upper bound of the support is always positive infinity no matter the
             parameters. Positive infinity is symbolized by {@code Integer.MAX_VALUE}.
            
             @return upper bound of the support (always {@code Integer.MAX_VALUE}
             for positive infinity)
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.isSupportConnected">
             {@inheritDoc}
            
             The support of this distribution is connected.
            
             @return {@code true}
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Distribution.PascalDistribution.binomialCoefficientLog(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Distribution.PascalDistribution.binomialCoefficient(System.Int32,System.Int32)" -->
        <member name="M:NReco.Math3.Distribution.PascalDistribution.gcd(System.Int32,System.Int32)">
             Computes the greatest common divisor of the absolute value of two
             numbers, using a modified version of the "binary gcd" method.
             See Knuth 4.5.2 algorithm B.
             The algorithm is due to Josef Stein (1961).
             <br/>
             Special cases:
             <ul>
              <li>The invocations
               {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},
               {@code gcd(Integer.MIN_VALUE, 0)} and
               {@code gcd(0, Integer.MIN_VALUE)} throw an
               {@code ArithmeticException}, because the result would be 2^31, which
               is too large for an int value.</li>
              <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and
               {@code gcd(x, 0)} is the absolute value of {@code x}, except
               for the special cases above.</li>
              <li>The invocation {@code gcd(0, 0)} is the only one which returns
               {@code 0}.</li>
             </ul>
            
             @param p Number.
             @param q Number.
             @return the greatest common divisor (never negative).
             @throws MathArithmeticException if the result cannot be represented as
             a non-negative {@code int} value.
             @since 1.1
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.gcdPositive(System.Int32,System.Int32)">
             Computes the greatest common divisor of two <em>positive</em> numbers
             (this precondition is <em>not</em> checked and the result is undefined
             if not fulfilled) using the "binary gcd" method which avoids division
             and modulo operations.
             See Knuth 4.5.2 algorithm B.
             The algorithm is due to Josef Stein (1961).
             <br/>
             Special cases:
             <ul>
              <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and
               {@code gcd(x, 0)} is the value of {@code x}.</li>
              <li>The invocation {@code gcd(0, 0)} is the only one which returns
               {@code 0}.</li>
             </ul>
            
             @param a Positive number.
             @param b Positive number.
             @return the greatest common divisor.
        </member>
        <member name="M:NReco.Math3.Distribution.PascalDistribution.mulAndCheck(System.Int32,System.Int32)">
             Multiply two integers, checking for overflow.
            
             @param x Factor.
             @param y Factor.
             @return the product {@code x * y}.
             @throws MathArithmeticException if the result can not be
             represented as an {@code int}.
             @since 1.1
        </member>
        <member name="T:NReco.Math3.Primes.Primes">
             Methods related to prime numbers in the range of <code>int</code>:
             <ul>
             <li>primality test</li>
             <li>prime number generation</li>
             <li>factorization</li>
             </ul>
            
             @version $Id: Primes.java 1538368 2013-11-03 13:57:37Z erans $
             @since 3.2
        </member>
        <member name="M:NReco.Math3.Primes.Primes.#ctor">
            Hide utility class.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Primes.Primes.isPrime(System.Int32)" -->
        <member name="M:NReco.Math3.Primes.Primes.nextPrime(System.Int32)">
             Return the smallest prime greater than or equal to n.
            
             @param n a positive number.
             @return the smallest prime greater than or equal to n.
             @; 0.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Primes.Primes.primeFactors(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.QRDecomposition.#ctor(System.Double[0:,0:])" -->
        <member name="M:NReco.Math3.QRDecomposition.getQ">
             Generates and returns the (economy-sized) orthogonal factor <tt>Q</tt>.
            
             @return <tt>Q</tt>
        </member>
        <member name="M:NReco.Math3.QRDecomposition.getR">
             Returns the upper triangular factor, <tt>R</tt>.
            
             @return <tt>R</tt>
        </member>
        <member name="M:NReco.Math3.QRDecomposition.hasFullRank">
             Returns whether the matrix <tt>A</tt> has full rank.
            
             @return true if <tt>R</tt>, and hence <tt>A</tt>, has full rank.
        </member>
        <member name="M:NReco.Math3.QRDecomposition.solve(System.Double[0:,0:])">
             Least squares solution of <tt>A*X = B</tt>; <tt>returns X</tt>.
            
             @param B A matrix with as many rows as <tt>A</tt> and any number of columns.
             @return <tt>X</tt> that minimizes the two norm of <tt>Q*R*X - B</tt>.
             @throws IllegalArgumentException if <tt>B.rows() != A.rows()</tt>.
        </member>
        <member name="M:NReco.Math3.QRDecomposition.ToString">
            Returns a rough string rendition of a QR.
        </member>
        <member name="T:NReco.CF.RandomUtils">
            <summary>
            The source of random stuff for the whole project. This lets us make all randomness in the project
            predictable, if desired, for when we run unit tests, which should be repeatable.
            </summary>
        </member>
        <member name="F:NReco.CF.RandomUtils.MAX_INT_SMALLER_TWIN_PRIME">
            The largest prime less than 2<sup>31</sup>-1 that is the smaller of a twin prime pair. 
        </member>
        <member name="M:NReco.CF.RandomUtils.hashDouble(System.Double)">
            @return what {@link Double#hashCode()} would return for the same value 
        </member>
        <member name="M:NReco.CF.RandomUtils.hashFloat(System.Single)">
            @return what {@link Float#hashCode()} would return for the same value 
        </member>
        <member name="M:NReco.CF.RandomUtils.nextTwinPrime(System.Int32)">
            <p>
            Finds next-largest "twin primes": numbers p and p+2 such that both are prime. Finds the smallest such p
            such that the smaller twin, p, is greater than or equal to n. Returns p+2, the larger of the two twins.
            </p>
        </member>
        <member name="T:NReco.Math3.Primes.SmallPrimes">
            <summary>Utility methods to work on primes within the <code>int</code> range.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NReco.Math3.Primes.SmallPrimes.PRIMES" -->
        <member name="F:NReco.Math3.Primes.SmallPrimes.PRIMES_LAST">
            The last number in PRIMES. */
        </member>
        <member name="M:NReco.Math3.Primes.SmallPrimes.#ctor">
            Hide utility class.
        </member>
        <member name="M:NReco.Math3.Primes.SmallPrimes.smallTrialDivision(System.Int32,System.Collections.Generic.List{System.Int32})">
            Extract small factors.
            @param n the number to factor, must be &gt; 0.
            @param factors the list where to add the factors.
            @return the part of n which remains to be factored, it is either a prime or a semi-prime
        </member>
        <member name="M:NReco.Math3.Primes.SmallPrimes.boundedTrialDivision(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32})">
            Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.
            @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2
            @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.
            @param factors the list where to add the factors.
            @return  n or 1 if factorization is completed.
        </member>
        <member name="M:NReco.Math3.Primes.SmallPrimes.trialDivision(System.Int32)">
            Factorization by trial division.
            @param n the number to factor
            @return the list of prime factors of n
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.Math3.Primes.SmallPrimes.millerRabinPrimeTest(System.Int32)" -->
        <member name="T:NReco.CF.Taste.Common.IRefreshable">
            <summary>
            Implementations of this interface have state that can be periodically refreshed. For example, an
            implementation instance might contain some pre-computed information that should be periodically refreshed.
            The <see cref="M:NReco.CF.Taste.Common.IRefreshable.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})"/> method triggers such a refresh.
            <para>
            All Taste components implement this. In particular, <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>s do. Callers may want to call
            <see cref="M:NReco.CF.Taste.Common.IRefreshable.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})"/> periodically to re-compute information throughout the system and bring it up
            to date, though this operation may be expensive.
            </para>
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Common.IRefreshable.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})">
            <summery>
            Triggers "refresh" -- whatever that means -- of the implementation. The general contract is that any
            {@link Refreshable} should always leave itself in a consistent, operational state, and that the refresh
            atomically updates internal state from old to new.
            </summery>
            <param name="alreadyRefreshed">
            <see cref="T:NReco.CF.Taste.Common.IRefreshable"/>s that are known to have already been
            refreshed as a result of an initial call to a <see cref="M:NReco.CF.Taste.Common.IRefreshable.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})"/> method on some
            object. This ensure that objects in a refresh dependency graph aren't refreshed twice
            needlessly.
            </param>
        </member>
        <member name="T:NReco.CF.Taste.Common.TasteException">
            <summary>
            An exception thrown when an error occurs inside the Taste engine.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Common.Weighting">
            <summary>
            A simple enum which gives symbolic names to the ideas of "weighted" and "unweighted", to make various API
            calls which take a weighting parameter more readable.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Eval.IDataModelBuilder">
            <summary>
            Implementations of this inner interface are simple helper classes which create a <see cref="T:NReco.CF.Taste.Model.IDataModel"/> to be
            used while evaluating a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>.
            </summary>
            <seealso cref="T:NReco.CF.Taste.Eval.IRecommenderBuilder"/>
            <seealso cref="T:NReco.CF.Taste.Eval.IRecommenderEvaluator"/>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IDataModelBuilder.BuildDataModel(NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Model.IPreferenceArray})">
            <summary>
            Builds a {@link DataModel} implementation to be used in an evaluation, given training data.
            </summary>
            <param name="trainingData">data to be used in the <see cref="T:NReco.CF.Taste.Model.IDataModel"/></param>
            <returns><see cref="T:NReco.CF.Taste.Model.IDataModel"/> based upon the given data</returns>
        </member>
        <member name="T:NReco.CF.Taste.Eval.IRecommenderBuilder">
            <summary>
            Implementations of this inner interface are simple helper classes which create a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> to be
            evaluated based on the given <see cref="T:NReco.CF.Taste.Model.IDataModel"/>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRecommenderBuilder.BuildRecommender(NReco.CF.Taste.Model.IDataModel)">
            <summary>
            Builds a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> implementation to be evaluated, using the given <see cref="T:NReco.CF.Taste.Model.IDataModel"/>.
            </summary>
            <param name="dataModel">{@link DataModel} to build the {@link Recommender} on</param>
            <returns>{@link Recommender} based upon the given {@link DataModel}</returns>
            <remarks>Throws TasteException if an error occurs while accessing the <see cref="T:NReco.CF.Taste.Model.IDataModel"/></remarks>
        </member>
        <member name="T:NReco.CF.Taste.Eval.IRecommenderEvaluator">
            <summary>
            Implementations of this interface evaluate the quality of a
            <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s recommendations.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRecommenderEvaluator.Evaluate(NReco.CF.Taste.Eval.IRecommenderBuilder,NReco.CF.Taste.Eval.IDataModelBuilder,NReco.CF.Taste.Model.IDataModel,System.Double,System.Double)">
             <summary>
             Evaluates the quality of a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s recommendations.
             The range of values that may be returned depends on the implementation, but <em>lower</em> values must
             mean better recommendations, with 0 being the lowest / best possible evaluation, meaning a perfect match.
             This method does not accept a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> directly, but
             rather a <see cref="!:NReco.CF.Taste.Recommender.IRecommenderBuilder"/> which can build the
             <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> to test on top of a given <see cref="T:NReco.CF.Taste.Model.IDataModel"/>.
             
             <para>
             Implementations will take a certain percentage of the preferences supplied by the given <see cref="T:NReco.CF.Taste.Model.IDataModel"/>
             as "training data". This is typically most of the data, like 90%. This data is used to produce
             recommendations, and the rest of the data is compared against estimated preference values to see how much
             the <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s predicted preferences match the user's
             real preferences. Specifically, for each user, this percentage of the user's ratings are used to produce
             recommendations, and for each user, the remaining preferences are compared against the user's real
             preferences.
             </para>
            
             <para>
             For large datasets, it may be desirable to only evaluate based on a small percentage of the data.
             <code>evaluationPercentage</code> controls how many of the <see cref="T:NReco.CF.Taste.Model.IDataModel"/>'s users are used in
             evaluation.
             </para>
            
             <para>
             To be clear, <code>trainingPercentage</code> and <code>evaluationPercentage</code> are not related. They
             do not need to add up to 1.0, for example.
             </para>
             </summary>
             <param name="recommenderBuilder">object that can build a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> to test</param>
             <param name="dataModelBuilder"><see cref="T:NReco.CF.Taste.Eval.IDataModelBuilder"/> to use, or if null, a default <see cref="T:NReco.CF.Taste.Model.IDataModel"/> implementation will be used</param>     
             <param name="dataModel">dataset to test on</param>  
             <param name="trainingPercentage">
             percentage of each user's preferences to use to produce recommendations; the rest are compared
             to estimated preference values to evaluate
             <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> performance
             </param>
             <param name="evaluationPercentage">
             percentage of users to use in evaluation
             </param>
             <returns>
             a "score" representing how well the <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s
             estimated preferences match real values; <em>lower</em> scores mean a better match and 0 is a perfect match
             </returns>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRecommenderEvaluator.GetMaxPreference">
            @deprecated see {@link DataModel#getMaxPreference()}
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRecommenderEvaluator.GetMinPreference">
            @deprecated see {@link DataModel#getMinPreference()}
        </member>
        <member name="T:NReco.CF.Taste.Eval.IRecommenderIRStatsEvaluator">
            <summary>
            Implementations collect information retrieval-related statistics on a
            <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s performance, including precision, recall and
            f-measure.
            </summary>
            
            <remarks>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval">Information retrieval</a>.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRecommenderIRStatsEvaluator.Evaluate(NReco.CF.Taste.Eval.IRecommenderBuilder,NReco.CF.Taste.Eval.IDataModelBuilder,NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Recommender.IDRescorer,System.Int32,System.Double,System.Double)">
            @param recommenderBuilder
                     object that can build a {@link NReco.CF.Taste.Recommender.Recommender} to test
            @param dataModelBuilder
                     {@link DataModelBuilder} to use, or if null, a default {@link DataModel} implementation will be
                     used
            @param dataModel
                     dataset to test on
            @param rescorer
                     if any, to use when computing recommendations
            @param at
                     as in, "precision at 5". The number of recommendations to consider when evaluating precision,
                     etc.
            @param relevanceThreshold
                     items whose preference value is at least this value are considered "relevant" for the purposes
                     of computations
            @return {@link IRStatistics} with resulting precision, recall, etc.
            @throws TasteException
                      if an error occurs while accessing the {@link DataModel}
        </member>
        <member name="T:NReco.CF.Taste.Eval.IRelevantItemsDataSplitter">
            Implementations of this interface determine the items that are considered relevant,
            and splits data into a training and test subset, for purposes of precision/recall
            tests as implemented by implementations of {@link RecommenderIRStatsEvaluator}.
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRelevantItemsDataSplitter.GetRelevantItemsIDs(System.Int64,System.Int32,System.Double,NReco.CF.Taste.Model.IDataModel)">
             During testing, relevant items are removed from a particular users' preferences,
             and a model is build using this user's other preferences and all other users.
            
             @param at                 Maximum number of items to be removed
             @param relevanceThreshold Minimum strength of preference for an item to be considered
                                       relevant
             @return IDs of relevant items
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRelevantItemsDataSplitter.ProcessOtherUser(System.Int64,NReco.CF.Taste.Impl.Common.FastIDSet,NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Model.IPreferenceArray},System.Int64,NReco.CF.Taste.Model.IDataModel)">
             Adds a single user and all their preferences to the training model.
            
             @param userID          ID of user whose preferences we are trying to predict
             @param relevantItemIDs IDs of items considered relevant to that user
             @param trainingUsers   the database of training preferences to which we will
                                    append the ones for otherUserID.
             @param otherUserID     for whom we are adding preferences to the training model
        </member>
        <!-- Badly formed XML comment ignored for member "T:NReco.CF.Taste.Impl.Common.FixedSizeSamplingIterator`1" -->
        <member name="T:NReco.CF.Taste.Impl.Common.IRetriever`2">
            <summary>
            Implementations can retrieve a value for a given key.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRetriever`2.Get(`0)">
            @param key key for which a value should be retrieved
            @return value for key
            @throws TasteException if an error occurs while retrieving the value
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.IRunningAverage">
            <summary>
            Interface for classes that can keep track of a running average of a series of numbers. One can add to or
            remove from the series, as well as update a datum in the series. The class does not actually keep track of
            the series of values, just its running average, so it doesn't even matter if you remove/change a value that
            wasn't added.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverage.AddDatum(System.Double)">
            @param datum
                     new item to add to the running average
            @throws IllegalArgumentException
                      if datum is {@link Double#NaN}
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverage.RemoveDatum(System.Double)">
            @param datum
                     item to remove to the running average
            @throws IllegalArgumentException
                      if datum is {@link Double#NaN}
            @throws InvalidOperationException
                      if count is 0
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverage.ChangeDatum(System.Double)">
            @param delta
                     amount by which to change a datum in the running average
            @throws IllegalArgumentException
                      if delta is {@link Double#NaN}
            @throws InvalidOperationException
                      if count is 0
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverage.Inverse">
            @return a (possibly immutable) object whose average is the negative of this object's
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.IRunningAverageAndStdDev">
            <p>
            Extends {@link RunningAverage} by adding standard deviation too.
            </p>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverageAndStdDev.GetStandardDeviation">
            @return standard deviation of data 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.IRunningAverageAndStdDev.Inverse">
            @return a (possibly immutable) object whose average is the negative of this object's
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.File.FileDataModel">
             <summary>
             A <see cref="T:NReco.CF.Taste.Model.IDataModel"/> backed by a delimited file.
             </summary>
             <remarks>
             This class expects a file where each line
             contains a user ID, followed by item ID, followed by optional preference value, followed by
             optional timestamp. Commas or tabs delimit fields:
             
             <para><code>userID,itemID[,preference[,timestamp]]</code></para>
            
             <para>
             Preference value is optional to accommodate applications that have no notion of a
             preference value (that is, the user simply expresses a
             preference for an item, but no degree of preference).
             </para>
            
             <para>
             The preference value is assumed to be parseable as a <code>double</code>. The user IDs and item IDs are
             read parsed as <code>long</code>s. The timestamp, if present, is assumed to be parseable as a
             <code>long</code>, though this can be overridden via <see cref="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.readTimestampFromString(System.String)"/>.
             The preference value may be empty, to indicate "no preference value", but cannot be empty. That is,
             this is legal:
             </para>
            
             <para><code>123,456,,129050099059</code></para>
            
             <p>But this isn't:</p>
            
             <para><code>123,456,129050099059</code></para>
            
             <para>
             It is also acceptable for the lines to contain additional fields. Fields beyond the third will be ignored.
             An empty line, or one that begins with '#' will be ignored as a comment.
             </para>
            
             <para>
             This class will reload data from the data file when <see cref="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})"/> is called, unless the file
             has been reloaded very recently already.
             </para>
            
             <para>
             This class will also look for update "delta" files in the same directory, with file names that start the
             same way (up to the first period). These files have the same format, and provide updated data that
             supersedes what is in the main data file. This is a mechanism that allows an application to push updates to
             <see cref="T:NReco.CF.Taste.Impl.Model.File.FileDataModel"/> without re-copying the entire data file.
             </para>
            
             <para>
             One small format difference exists. Update files must also be able to express deletes.
             This is done by ending with a blank preference value, as in "123,456,".
             </para>
            
             <para>
             Note that it's all-or-nothing -- all of the items in the file must express no preference, or the all must.
             These cannot be mixed. Put another way there will always be the same number of delimiters on every line of
             the file!
             </para>
            
             <para>
             This class is not intended for use with very large amounts of data (over, say, tens of millions of rows).
             For that, a JDBC-backed {@link DataModel} and a database are more appropriate.
             </para>
            
             <para>
             It is possible and likely useful to subclass this class and customize its behavior to accommodate
             application-specific needs and input formats.
             </para>
             </remarks>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.AbstractDataModel">
            <summary>
            Contains some features common to all implementations.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Model.IDataModel">
            <summary>
            Implementations represent a repository of information about users and their associated <see cref="T:NReco.CF.Taste.Model.IPreference"/>s
            for items.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetUserIDs">
            <summary>
            All user IDs in the model, in order
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetPreferencesFromUser(System.Int64)">
            <summary>
            Get preferences for specified user ID
            </summary>
            <param name="userID">ID of user to get prefs for</param>
            <returns>user's preferences, ordered by item ID</returns>
            <remarks>Throws NReco.CF.Taste.Common.NoSuchUserException if the user does not exist</remarks>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetItemIDsFromUser(System.Int64)">
            <summary>
            Get list of item IDs for specified user ID
            </summary>
            <param name="userID">ID of user to get prefs for</param>
            <returns>IDs of items user expresses a preference for</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetItemIDs">
            <summary>
            Get all item IDs in the model
            </summary>
            <returns><see cref="T:System.Collections.IEnumerator"/> of all item IDs in the model, in order</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetPreferencesForItem(System.Int64)">
            <summary>
            Get all existing preferences by specified item ID
            </summary>
            <param name="itemID">item ID</param>
            <returns>all existing <see cref="T:NReco.CF.Taste.Model.IPreference"/>s expressed for that item, ordered by user ID, as an array</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetPreferenceValue(System.Int64,System.Int64)">
            <summary>
            Retrieves the preference value for a single user and item.
            </summary>
            <param name="userID">user ID to get pref value from</param>
            <param name="itemID">item ID to get pref value for</param>
            <returns>preference value from the given user for the given item or null if none exists</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetPreferenceTime(System.Int64,System.Int64)">
            <summary>
            Retrieves the time at which a preference value from a user and item was set, if known.
            </summary>
            <param name="userID">user ID for preference in question</param>
            <param name="itemID">item ID for preference in question</param>
            <returns>time at which preference was set or null if no preference exists or its time is not known</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetNumItems">
            <summary>
            Get total number of items in the model
            </summary>
            <returns>total number of items known to the model. This is generally the union of all items preferred by at least one user but could include more.</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetNumUsers">
            <summary>
            Get total number of users in the model
            </summary>
            <returns>total number of users known to the model.</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetNumUsersWithPreferenceFor(System.Int64)">
            <summary>
            Ger number of users that prefer specified item ID
            </summary>
            <param name="itemID">item ID to check for</param>
            <returns>the number of users who have expressed a preference for the item</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetNumUsersWithPreferenceFor(System.Int64,System.Int64)">
            <summary>
            Ger number of users that prefer both specified item IDs
            </summary>
            <param name="itemID1">first item ID to check for</param>
            <param name="itemID2">second item ID to check for</param>
            <returns>the number of users who have expressed a preference for the items</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.SetPreference(System.Int64,System.Int64,System.Single)">
            <summary>
            Sets a particular preference (item plus rating) for a user.
            </summary>
            <param name="userID">user to set preference for</param>
            <param name="itemID">item to set preference for</param>
            <param name="value">preference value</param>
            <remarks>
            throws NReco.CF.Taste.Common.NoSuchItemException if the item does not exist.
            throws NReco.CF.Taste.Common.NoSuchUserException if the user does not exist.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.RemovePreference(System.Int64,System.Int64)">
            <summary>
            Removes a particular preference for a user.
            </summary>
            <param name="userID">user from which to remove preference</param>
            <param name="itemID">item to remove preference for</param>
            <remarks>
            Throws NReco.CF.Taste.Common.NoSuchItemException if the item does not exist.
            Throws NReco.CF.Taste.Common.NoSuchUserException if the user does not exist
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.HasPreferenceValues">
            <summary>
            Check if data model has distinct preference values
            </summary>
            <returns>true if this implementation actually stores and returns distinct preference values that is, if it is not a 'bool' DataModel</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetMaxPreference">
            <summary>
            Get maximum preference value that is possible in the current problem domain being evaluated. 
            </summary>
            <remarks>
            For example, if the domain is movie ratings on a scale of 1 to 5, this should be 5. While a
            <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> may estimate a preference value above 5.0, it
            isn't "fair" to consider that the system is actually suggesting an impossible rating of, say, 5.4 stars.
            In practice the application would cap this estimate to 5.0. Since evaluators evaluate
            the difference between estimated and actual value, this at least prevents this effect from unfairly
            penalizing a <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Model.IDataModel.GetMinPreference">
            <summary>
            Get minimum preference value that is possible in the current problem domain being evaluated.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.#ctor(System.String)">
            @param dataFile
                     file containing preferences data. If file is compressed (and name ends in .gz or .zip
                     accordingly) it will be decompressed as it is read)
            @throws FileNotFoundException
                      if dataFile does not exist
            @throws IOException
                      if file can't be read
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.#ctor(System.String,System.String)">
            @param delimiterRegex If your data file don't use '\t' or ',' as delimiter, you can specify 
            a custom regex pattern.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.#ctor(System.String,System.Boolean,System.Int64,System.Boolean,System.String)">
            @param transpose
                     transposes user IDs and item IDs -- convenient for 'flipping' the data model this way
            @param minReloadIntervalMS
             the minimum interval in milliseconds after which a full reload of the original datafile is done
             when refresh() is called
            @see #FileDataModel(File)
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.findUpdateFilesAfter(System.DateTime)">
            Finds update delta files in the same directory as the data file. This finds any file whose name starts
            the same way as the data file (up to first period) but isn't the data file itself. For example, if the
            data file is /foo/data.txt.gz, you might place update files at /foo/data.1.txt.gz, /foo/data.2.txt.gz,
            etc.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.processLine``1(System.String,NReco.CF.Taste.Impl.Common.FastByIDMap{``0},NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Impl.Common.FastByIDMap{System.Nullable{System.DateTime}}},System.Boolean)">
             <p>
             Reads one line from the input file and adds the data to a {@link FastByIDMap} data structure which maps user IDs
             to preferences. This assumes that each line of the input file corresponds to one preference. After
             reading a line and determining which user and item the preference pertains to, the method should look to
             see if the data contains a mapping for the user ID already, and if not, add an empty data structure of preferences
             as appropriate to the data.
             </p>
            
             <p>
             Note that if the line is empty or begins with '#' it will be ignored as a comment.
             </p>
            
             @param line
                      line from input data file
             @param data
                      all data read so far, as a mapping from user IDs to preferences
             @param fromPriorData an implementation detail -- if true, data will map IDs to
              {@link PreferenceArray} since the framework is attempting to read and update raw
              data that is already in memory. Otherwise it maps to {@link Collection}s of
              {@link Preference}s, since it's reading fresh data. Subclasses must be prepared
              to handle this wrinkle.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.readUserIDFromString(System.String)">
            Subclasses may wish to override this if ID values in the file are not numeric. This provides a hook by
            which subclasses can inject an {@link NReco.CF.Taste.Model.IDMigrator} to perform
            translation.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.readItemIDFromString(System.String)">
            Subclasses may wish to override this if ID values in the file are not numeric. This provides a hook by
            which subclasses can inject an {@link NReco.CF.Taste.Model.IDMigrator} to perform
            translation.
        </member>
        <member name="F:NReco.CF.Taste.Impl.Model.File.FileDataModel.unixTimestampEpochStart">
            Subclasses may wish to override this to change how time values in the input file are parsed.
            By default they are expected to be numeric, expressing a time as milliseconds since the epoch.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.SetPreference(System.Int64,System.Int64,System.Single)">
            Note that this method only updates the in-memory preference data that this {@link FileDataModel}
            maintains; it does not modify any data on disk. Therefore any updates from this method are only
            temporary, and lost when data is reloaded from a file. This method should also be considered relatively
            slow.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.File.FileDataModel.RemovePreference(System.Int64,System.Int64)">
            See the warning at {@link #setPreference(long, long, float)}. 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.ALSWRFactorizer">
             <summary>
             Factorizes the rating matrix using "Alternating-Least-Squares with Weighted-λ-Regularization" as described in
             <a href="http://www.hpl.hp.com/personal/Robert_Schreiber/papers/2008%20AAIM%20Netflix/netflix_aaim08(submitted).pdf">
             "Large-scale Collaborative Filtering for the Netflix Prize"</a>
            
              also supports the implicit feedback variant of this approach as described in "Collaborative Filtering for Implicit
              Feedback Datasets" available at http://research.yahoo.com/pub/2433
             </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.AbstractFactorizer">
            <summary>
            Base class for <see cref="T:NReco.CF.Taste.Impl.Recommender.SVD.IFactorizer"/>s, provides ID to index mapping
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.IFactorizer">
            <summary>Implementation must be able to create a factorization of a rating matrix</summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ALSWRFactorizer.numFeatures">
            number of features used to compute this factorization 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ALSWRFactorizer.lambda">
            parameter to control the regularization 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ALSWRFactorizer.numIterations">
            number of iterations 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ALSWRFactorizer.alpha">
            confidence weighting parameter, only necessary when working with implicit feedback 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.FilePersistenceStrategy">
            <summary>Provides a file-based persistent store. </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy">
            <summary>
            Provides storage for <see cref="T:NReco.CF.Taste.Impl.Recommender.SVD.Factorization"/>s
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy.Load">
            <summary>Load a factorization from a persistent store.</summary>
            <returns>a Factorization or null if the persistent store is empty.</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy.MaybePersist(NReco.CF.Taste.Impl.Recommender.SVD.Factorization)">
            <summary>Write a factorization to a persistent store unless it already
            contains an identical factorization.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.FilePersistenceStrategy.#ctor(System.String)">
            @param file the file to use for storage. If the file does not exist it will be created when required.
        </member>
        <member name="T:NReco.CF.Taste.Eval.IRStatistics">
            <summary>
            Implementations encapsulate information retrieval-related statistics about a
            <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>'s recommendations.
            </summary>
            <remarks>See <a href="http://en.wikipedia.org/wiki/Information_retrieval">Information retrieval</a>.</remarks>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetPrecision">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval#Precision">Precision</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetRecall">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval#Recall">Recall</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetFallOut">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval#Fall-Out">Fall-Out</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetF1Measure">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval#F-measure">F-measure</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetFNMeasure(System.Double)">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Information_retrieval#F-measure">F-measure</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetNormalizedDiscountedCumulativeGain">
            <summary>
            See <a href="http://en.wikipedia.org/wiki/Discounted_cumulative_gain#Normalized_DCG">
            Normalized Discounted Cumulative Gain</a>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Eval.IRStatistics.GetReach">
            <summary>
            The fraction of all users for whom recommendations could be produced
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.BitSet">
            <summary>
            A simplified and streamlined version of BitSet
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.Cache`2">
            <summary>
            An efficient Map-like class which caches values for keys. Values are not "put" into a <see cref="!:Cache"/>;
            instead the caller supplies the instance with an implementation of <see cref="!:IRetriever"/> which can load the
            value for a given key.
            <para>
            The cache does not support <code>null</code> keys.
            </para>
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.#ctor(NReco.CF.Taste.Impl.Common.IRetriever{`0,`1})">
            <summary>
            Creates a new cache based on the given <see cref="!:IRetriever"/>.
            </summary>
            <param name="retriever">object which can retrieve values for keys</param>       
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.#ctor(NReco.CF.Taste.Impl.Common.IRetriever{`0,`1},System.Int32)">
            <summary>
            Creates a new cache based on the given {@link Retriever} and with given maximum size.
            </summary>
            <param name="retriever">object which can retrieve values for keys</param>
            <param name="maxEntries">maximum number of entries the cache will store before evicting some</param>     
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.Get(`0)">
            <summary>
            Returns cached value for a key. If it does not exist, it is loaded using a {@link Retriever}.
            </summary>
            <param name="key">cache key</param>
            <returns>value for that key</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.Remove(`0)">
            <summary>
            Uncaches any existing value for a given key.
            </summary>
            <param name="key">cache key</param>     
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.RemoveKeysMatching(System.Func{`0,System.Boolean})">
            <summary>Clears all cache entries whose key matches the given predicate.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.RemoveValueMatching(System.Func{`1,System.Boolean})">
            <summary>Clears all cache entries whose value matches the given predicate.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.Cache`2.Clear">
            <summary>
            Clears the cache.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FastByIDMap`1">
            @see FastMap
            @see FastIDSet
        </member>
        <member name="F:NReco.CF.Taste.Impl.Common.FastByIDMap`1.REMOVED">
            Dummy object used to represent a key that has been removed. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastByIDMap`1.#ctor">
            Creates a new {@link FastByIDMap} with default capacity. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastByIDMap`1.#ctor(System.Int32,System.Int32,System.Single)">
            Creates a new {@link FastByIDMap} whose capacity can accommodate the given number of entries without rehash.
            
            @param size desired capacity
            @param maxSize max capacity
            @param loadFactor ratio of internal hash table size to current size
            @throws IllegalArgumentException if size is less than 0, maxSize is less than 1
             or at least half of {@link RandomUtils#MAX_INT_SMALLER_TWIN_PRIME}, or
             loadFactor is less than 1
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FastIDSet">
            @see FastByIDMap
        </member>
        <member name="F:NReco.CF.Taste.Impl.Common.FastIDSet.REMOVED">
            Dummy object used to represent a key that has been removed. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastIDSet.#ctor">
            Creates a new {@link FastIDSet} with default capacity. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastIDSet.find(System.Int64)">
            @see #findForAdd(long)
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastIDSet.findForAdd(System.Int64)">
            @see #find(long)
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FastIDSet.IntersectionSize(NReco.CF.Taste.Impl.Common.FastIDSet)">
            Convenience method to quickly compute just the size of the intersection with another {@link FastIDSet}.
            
            @param other
                     {@link FastIDSet} to intersect with
            @return number of elements in intersection
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FixedRunningAverage">
            <p>
            A simple class that represents a fixed value of an average and count. This is useful
            when an API needs to return {@link RunningAverage} but is not in a position to accept
            updates to it.
            </p>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FixedRunningAverage.ChangeDatum(System.Double)">
            @throws NotSupportedException
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FixedRunningAverageAndStdDev">
            <p>
            A simple class that represents a fixed value of an average, count and standard deviation. This is useful
            when an API needs to return {@link RunningAverageAndStdDev} but is not in a position to accept
            updates to it.
            </p>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FullRunningAverage">
            <summary>
            A simple class that can keep track of a running average of a series of numbers. One can add to or remove
            from the series, as well as update a datum in the series. The class does not actually keep track of the
            series of values, just its running average, so it doesn't even matter if you remove/change a value that
            wasn't added.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FullRunningAverage.AddDatum(System.Double)">
            @param datum
                     new item to add to the running average
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FullRunningAverage.RemoveDatum(System.Double)">
            @param datum
                     item to remove to the running average
            @throws InvalidOperationException
                      if count is 0
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FullRunningAverage.ChangeDatum(System.Double)">
            @param delta
                     amount by which to change a datum in the running average
            @throws InvalidOperationException
                      if count is 0
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.FullRunningAverageAndStdDev">
            <summary>
            Extends <see cref="T:NReco.CF.Taste.Impl.Common.FullRunningAverage"/> to add a running standard deviation computation.
            Uses Welford's method, as described at http://www.johndcook.com/standard_deviation.html
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.FullRunningAverageAndStdDev.ChangeDatum(System.Double)">
            @throws NotSupportedException
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.RefreshHelper">
            <summary>
            A helper class for implementing <see cref="T:NReco.CF.Taste.Common.IRefreshable"/>. This object is typically included in an implementation
            <see cref="T:NReco.CF.Taste.Common.IRefreshable"/> to implement <see cref="M:NReco.CF.Taste.Common.IRefreshable.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})"/>.
            It execute the class's own supplied update logic, after updating all the object's dependencies. This also ensures that dependencies
            are not updated multiple times.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.RefreshHelper.#ctor(System.Action)">
            @param refreshRunnable
                     encapsulates the containing object's own refresh logic
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.RefreshHelper.AddDependency(NReco.CF.Taste.Common.IRefreshable)">
            <summary>Add a dependency to be refreshed first when the encapsulating object does.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.RefreshHelper.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})">
            <summary>
            Typically this is called in {@link Refreshable#refresh(java.util.Collection)} and is the entire body of  that method.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.RefreshHelper.BuildRefreshed(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})">
             Creates a new and empty {@link Collection} if the method parameter is {@code null}.
            
             @param currentAlreadyRefreshed
                      {@link Refreshable}s to refresh later on
             @return an empty {@link Collection} if the method param was {@code null} or the unmodified method
                     param.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.RefreshHelper.MaybeRefresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable},NReco.CF.Taste.Common.IRefreshable)">
            <summary>
            Adds the specified {@link Refreshable} to the given collection of {@link Refreshable}s if it is not
            already there and immediately refreshes it.
            </summary>
            <param name="alreadyRefreshed">the collection of <see cref="T:NReco.CF.Taste.Common.IRefreshable"/>s</param>
            <param name="refreshable">the <see cref="T:NReco.CF.Taste.Common.IRefreshable"/> to potentially add and refresh</param>     
        </member>
        <!-- Badly formed XML comment ignored for member "T:NReco.CF.Taste.Impl.Common.SamplinglongPrimitiveIterator" -->
        <member name="M:NReco.CF.Taste.Impl.Common.WeightedRunningAverage.GetCount">
            @return {@link #getTotalWeight()} 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Common.WeightedRunningAverageAndStdDev">
            This subclass also provides for a weighted estimate of the sample standard deviation.
            See <a href="http://en.wikipedia.org/wiki/Mean_square_weighted_deviation">estimate formulae here</a>.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Common.WeightedRunningAverageAndStdDev.ChangeDatum(System.Double,System.Double)">
            @throws NotSupportedException
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.AbstractDifferenceRecommenderEvaluator">
            Abstract superclass of a couple implementations, providing shared functionality.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.AverageAbsoluteDifferenceRecommenderEvaluator">
            <summary>
            A <see cref="T:NReco.CF.Taste.Eval.IRecommenderEvaluator"/> which computes the average absolute
            difference between predicted and actual ratings for users.
            </summary>
            <remarks>This algorithm is also called "mean average error".</remarks>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.GenericRecommenderIRStatsEvaluator">
            <summary>
            For each user, these implementation determine the top <code>n</code> preferences, then evaluate the IR
            statistics based on a <see cref="T:NReco.CF.Taste.Model.IDataModel"/> that does not have these values. This number <code>n</code> is the
            "at" value, as in "precision at 5". For example, this would mean precision evaluated by removing the top 5
            preferences for a user and then finding the percentage of those 5 items included in the top 5
            recommendations for that user.
            </summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Eval.GenericRecommenderIRStatsEvaluator.CHOOSE_THRESHOLD">
            Pass as "relevanceThreshold" argument to
            {@link #evaluate(RecommenderBuilder, DataModelBuilder, DataModel, IDRescorer, int, double, double)} to
            have it attempt to compute a reasonable threshold. Note that this will impact performance.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.GenericRelevantItemsDataSplitter">
            <summary>
            Picks relevant items to be those with the strongest preference, and
            includes the other users' preferences in full.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.LoadEvaluator">
            <summary>
            Simple helper class for running load on a Recommender.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator">
            <summary>
            Evaluate recommender by comparing order of all raw prefs with order in 
            recommender's output for that user. Can also compare data models.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.mask(NReco.CF.Taste.Impl.Common.FastIDSet,NReco.CF.Taste.Impl.Common.FastIDSet,System.Int64)">
            This exists because FastIDSet has 'retainAll' as MASK, but there is 
            no count of the number of items in the set. size() is supposed to do 
            this but does not work.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.scoreCommonSubset(System.String,System.Int64,System.Int32,System.Int32,System.Int64[],System.Int64[])">
             Common Subset Scoring
            
             These measurements are given the set of results that are common to both
             recommendation lists. They only get ordered lists.
            
             These measures all return raw numbers do not correlate among the tests.
             The numbers are not corrected against the total number of samples or the
             number of common items.
             The one contract is that all measures are 0 for an exact match and an
             increasing positive number as differences increase.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.normalWilcoxon(System.Int32[],System.Int32[])">
            Normal-distribution probability value for matched sets of values.
            Based upon:
            http://comp9.psych.cornell.edu/Darlington/normscor.htm
            
            The Standard Wilcoxon is not used because it requires a lookup table.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.getVectorZ(System.Int64[],System.Int64[],System.Int32[],System.Int32[])">
            vector Z is a list of distances between the correct value and the recommended value
            Z[i] = position i of correct itemID - position of correct itemID in recommendation list
            can be positive or negative
            the smaller the better - means recommendations are closer
            both are the same length, and both sample from the same set
            
            destructive to items arrays - allows N log N instead of N^2 order
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.wilcoxonRanks(System.Int32[],System.Int32[],System.Double[],System.Double[])">
            Ranks are the position of the value from low to high, divided by the # of values.
            I had to walk through it a few times.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Eval.OrderBasedRecommenderEvaluator.sort(System.Int64[],System.Int64[])">
            Do bubble sort and return number of swaps needed to match preference lists.
            Sort itemsR using itemsL as the reference order.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Eval.RMSRecommenderEvaluator">
            <summary>
            A <see cref="T:NReco.CF.Taste.Eval.IRecommenderEvaluator"/> which computes the "root mean squared"
            difference between predicted and actual ratings for users. This is the square root of the average of this
            difference, squared.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray"/> but stores preferences for one item (all item IDs the same) rather
            than one user.
            </summary>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.BooleanPreference"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray"/>
        </member>
        <member name="T:NReco.CF.Taste.Model.IPreferenceArray">
            <summary>
            An alternate representation of an array of {@link Preference}.
            Implementations, in theory, can produce a more memory-efficient representation.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.Length">
            <summary>
            Size of length of the "array"
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.Get(System.Int32)">
            <summary>
            Get preference at specified index
            </summary>
            <param name="i">index</param>
            <returns>a materialized <see cref="T:NReco.CF.Taste.Model.IPreference"/> representation of the preference at i</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.Set(System.Int32,NReco.CF.Taste.Model.IPreference)">
            <summary>
            Sets preference at i from information in the given <see cref="T:NReco.CF.Taste.Model.IPreference"/>
            </summary>
            <param name="i">index</param>
            <param name="pref">pref</param>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.GetUserID(System.Int32)">
            <summary>
            Get user ID from preference at specified index
            </summary>
            <param name="i">index</param>
            <returns>user ID from preference at i</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SetUserID(System.Int32,System.Int64)">
            Sets user ID for preference at i.
            
            @param i
                     index
            @param userID
                     new user ID
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.GetItemID(System.Int32)">
            <summary>
            Get item ID from preference at specified index
            </summary>
            <param name="i">index</param>
            <returns>item ID from preference at i</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SetItemID(System.Int32,System.Int64)">
            <summary>
            Sets item ID for preference at i.
            </summary>
            <param name="i">index</param>
            <param name="itemID">new item ID</param>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.GetIDs">
            <summary>
            Get all IDs
            </summary>
            <returns>all user or item IDs</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.GetValue(System.Int32)">
            <summary>
            Get preference value
            </summary>
            <param name="i">index</param>
            <returns>preference value from preference at i</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SetValue(System.Int32,System.Single)">
            <summary>
            Sets preference value for preference at i.
            </summary>
            <param name="i">index</param>
            <param name="value">new preference value</param>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.Clone">
            <summary>
            Clone object instance
            </summary>
            <returns>independent copy of this object</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SortByUser">
            <summary>
            Sorts underlying array by user ID, ascending.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SortByItem">
            <summary>
            Sorts underlying array by item ID, ascending.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SortByValue">
            <summary>
            Sorts underlying array by preference value, ascending.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.SortByValueReversed">
            <summary>
            Sorts underlying array by preference value, descending.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.HasPrefWithUserID(System.Int64)">
            <summary>
            Check if array contains a preference with given user ID
            </summary>
            <param name="userID">user ID</param>
            <returns>true if array contains a preference with given user ID</returns>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreferenceArray.HasPrefWithItemID(System.Int64)">
            <summary>
            Check if array contains a preference with given item ID
            </summary>
            <param name="itemID">item ID</param>
            <returns>true if array contains a preference with given item ID</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray.#ctor(System.Int64[],System.Int64)">
            This is a private copy constructor for clone().
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray.SetItemID(System.Int32,System.Int64)">
            {@inheritDoc}
            
            Note that this method will actually set the item ID for <em>all</em> preferences.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray.GetIDs">
            @return all user IDs
        </member>
        <member name="T:NReco.CF.Taste.Model.IPreference">
            <summary>
            A <see cref="T:NReco.CF.Taste.Model.IPreference"/> encapsulates an item and a preference value, which indicates the strength of the
            preference for it. <see cref="T:NReco.CF.Taste.Model.IPreference"/>s are associated to users.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreference.GetUserID">
            <summary>
            ID of user who prefers the item 
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreference.GetItemID">
            <summary>
            Item ID that is preferred 
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreference.GetValue">
            <summary>
            Strength of the preference for that item. 
            </summary>
            <remarks>Zero should indicate "no preference either way"; positive values indicate preference and negative values indicate dislike.</remarks>
        </member>
        <member name="M:NReco.CF.Taste.Model.IPreference.SetValue(System.Single)">
            <summary>
            Sets the strength of the preference for this item
            </summary>
            <param name="value">new preference</param>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.BooleanPreference">
            <summary>
            Encapsulates a simple bool "preference" for an item whose value does not matter (is fixed at 1.0). This
            is appropriate in situations where users conceptually have only a general "yes" preference for items,
            rather than a spectrum of preference values.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray"/> but stores, conceptually, <see cref="T:NReco.CF.Taste.Impl.Model.BooleanPreference"/> objects which
            have no associated preference value.
            </summary>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.BooleanPreference"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray"/>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray.#ctor(System.Int64[],System.Int64)">
            This is a private copy constructor for clone().
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray.SetUserID(System.Int32,System.Int64)">
            {@inheritDoc}
            
            Note that this method will actually set the user ID for <em>all</em> preferences.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.BooleanUserPreferenceArray.GetIDs">
            @return all item IDs
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel">
            <summary>
            A simple <see cref="T:NReco.CF.Taste.Model.IDataModel"/> which uses given user data as its data source. This implementation
            is mostly useful for small experiments and is not recommended for contexts where performance is important.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.#ctor(NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Impl.Common.FastIDSet})">
            <summary>
            Creates a new <see cref="T:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel"/> from the given users (and their preferences). This
            <see cref="T:NReco.CF.Taste.Model.IDataModel"/> retains all this information in memory and is effectively immutable.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.#ctor(NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Impl.Common.FastIDSet},NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Impl.Common.FastByIDMap{System.Nullable{System.DateTime}}})">
             <p>
             Creates a new {@link GenericDataModel} from the given users (and their preferences). This
             {@link DataModel} retains all this information in memory and is effectively immutable.
             </p>
            
             @param userData users to include
             @param timestamps optionally, provided timestamps of preferences as milliseconds since the epoch.
              User IDs are mapped to maps of item IDs to long timestamps.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.#ctor(NReco.CF.Taste.Model.IDataModel)">
            <p>
            Creates a new {@link GenericDataModel} containing an immutable copy of the data from another given
            {@link DataModel}.
            </p>
            
            @param dataModel
                     {@link DataModel} to copy
            @throws TasteException
                      if an error occurs while retrieving the other {@link DataModel}'s users
            @deprecated without direct replacement.
             Consider {@link #toDataMap(DataModel)} with {@link #GenericBooleanPrefDataModel(FastByIDMap)}
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.toDataMap(NReco.CF.Taste.Model.IDataModel)">
             Exports the simple user IDs and associated item IDs in the data model.
            
             @return a {@link FastByIDMap} mapping user IDs to {@link FastIDSet}s representing
              that user's associated items
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.getRawUserData">
            This is used mostly internally to the framework, and shouldn't be relied upon otherwise.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.getRawItemData">
            This is used mostly internally to the framework, and shouldn't be relied upon otherwise.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericBooleanPrefDataModel.GetPreferencesFromUser(System.Int64)">
            @throws NoSuchUserException
                      if there is no such user
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.GenericDataModel">
            <summary>
            A simple <see cref="T:NReco.CF.Taste.Model.IDataModel"/> which uses a given list of users as its data source. This implementation
            is mostly useful for small experiments and is not recommended for contexts where performance is important.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.#ctor(NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Model.IPreferenceArray})">
            <summary>
            Creates a new <see cref="T:NReco.CF.Taste.Impl.Model.GenericDataModel"/> from the given users (and their preferences). This
            <see cref="T:NReco.CF.Taste.Model.IDataModel"/> retains all this information in memory and is effectively immutable.
            </summary>
            <param name="userData">userData users to include; (see also <see cref="!:GenericDataModel.ToDataMap(FastByIDMap, bool)"/>)</param>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.#ctor(NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Model.IPreferenceArray},NReco.CF.Taste.Impl.Common.FastByIDMap{NReco.CF.Taste.Impl.Common.FastByIDMap{System.Nullable{System.DateTime}}})">
            <summary>
            Creates a new <see cref="T:NReco.CF.Taste.Impl.Model.GenericDataModel"/> from the given users (and their preferences). This
            <see cref="T:NReco.CF.Taste.Model.IDataModel"/> retains all this information in memory and is effectively immutable.
            </summary>
            <param name="userData">users to include; (see also <see cref="!:GenericDataModel.ToDataMap(FastByIDMap, bool)"/>)</param>
            <param name="timestamps">timestamps optionally, provided timestamps of preferences as milliseconds since the epoch. User IDs are mapped to maps of item IDs to long timestamps.</param>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.#ctor(NReco.CF.Taste.Model.IDataModel)">
            <summary>
            Creates a new <see cref="T:NReco.CF.Taste.Impl.Model.GenericDataModel"/> containing an immutable copy of the data from another given
            <see cref="T:NReco.CF.Taste.Model.IDataModel"/>.
            </summary>
            <param name="dataModel">dataModel <see cref="T:NReco.CF.Taste.Model.IDataModel"/> to copy</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.CF.Taste.Impl.Model.GenericDataModel.ToDataMap(NReco.CF.Taste.Impl.Common.FastByIDMap{System.Collections.Generic.IList{NReco.CF.Taste.Model.IPreference}},System.Boolean)" -->
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.ToDataMap(NReco.CF.Taste.Model.IDataModel)">
            <summary>Exports the simple user IDs and preferences in the data model.</summary>
            <returns>a <see cref="!:FastByIDMap"/> mapping user IDs to <see cref="T:NReco.CF.Taste.Model.IPreferenceArray"/>s representing that user's preferences</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.GetRawUserData">
            <summary>This is used mostly internally to the framework, and shouldn't be relied upon otherwise.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.GetRawItemData">
            <summary>This is used mostly internally to the framework, and shouldn't be relied upon otherwise.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericDataModel.GetPreferencesFromUser(System.Int64)">
            @throws NoSuchUserException
                      if there is no such user
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray"/> but stores preferences for one item (all item IDs the same) rather
            than one user.
            </summary>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.BooleanItemPreferenceArray"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray"/>
            <seealso cref="T:NReco.CF.Taste.Impl.Model.GenericPreference"/> 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray.#ctor(System.Int64[],System.Int64,System.Single[])">
            This is a private copy constructor for clone().
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray.SetItemID(System.Int32,System.Int64)">
            {@inheritDoc}
            
            Note that this method will actually set the item ID for <em>all</em> preferences.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray.GetIDs">
            @return all user IDs
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.GenericPreference">
            <summary>
            A simple {@link Preference} encapsulating an item and preference value.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Model.GenericItemPreferenceArray"/> but stores preferences for one user (all user IDs the same) rather
            than one item.
            <para>
            This implementation maintains two parallel arrays, of item IDs and values. The idea is to save allocating
            <see cref="T:NReco.CF.Taste.Model.IPreference"/> objects themselves. This saves the overhead of <see cref="T:NReco.CF.Taste.Model.IPreference"/> objects but also
            duplicating the user ID value.
            </para>
            </summary>
            @see BooleanUserPreferenceArray
            @see GenericItemPreferenceArray
            @see GenericPreference
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray.#ctor(System.Int64[],System.Int64,System.Single[])">
            This is a private copy constructor for clone().
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray.SetUserID(System.Int32,System.Int64)">
            {@inheritDoc}
            
            Note that this method will actually set the user ID for <em>all</em> preferences.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.GenericUserPreferenceArray.GetIDs">
            @return all item IDs
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel">
             <summary>
             <para>
             This is a special thread-safe version of <see cref="T:NReco.CF.Taste.Impl.Model.PlusAnonymousUserDataModel"/>
             which allow multiple concurrent anonymous requests.
             </para>
            
             <para>
             To use it, you have to estimate the number of concurrent anonymous users of your application.
             The pool of users with the given size will be created. For each anonymous recommendations request,
             a user has to be taken from the pool and returned back immediately afterwards.
             </para>
            
             <para>
             If no more users are available in the pool, anonymous recommendations cannot be produced.
             </para>
             </summary>
             <example>
             Setup:
             <code>
             int concurrentUsers = 100;
             IDataModel realModel = ..
             PlusAnonymousConcurrentUserDataModel plusModel =
               new PlusAnonymousConcurrentUserDataModel(realModel, concurrentUsers);
             IRecommender recommender = ...;
             </code>
            
             Real-time recommendation:
             <code>
             PlusAnonymousConcurrentUserDataModel plusModel =
               (PlusAnonymousConcurrentUserDataModel) recommender.GetDataModel();
            
             // Take the next available anonymous user from the pool
             long anonymousUserID = plusModel.TakeAvailableUser();
            
             IPreferenceArray tempPrefs = ..
             tempPrefs.SetUserID(0, anonymousUserID);
             tempPrefs.SetItemID(0, itemID);
             plusModel.SetTempPrefs(tempPrefs, anonymousUserID);
            
             // Produce recommendations
             recommender.Recommend(anonymousUserID, howMany);
            
             // It is very IMPORTANT to release user back to the pool
             plusModel.ReleaseUser(anonymousUserID);
             </code>
             </example>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Model.PlusAnonymousUserDataModel">
             <summary>
             <para>
             This <see cref="T:NReco.CF.Taste.Model.IDataModel"/> decorator class is useful in a situation where you wish to recommend to a user that
             doesn't really exist yet in your actual <see cref="T:NReco.CF.Taste.Model.IDataModel"/>. For example maybe you wish to recommend DVDs to
             a user who has browsed a few titles on your DVD store site, but, the user is not yet registered.
             </para>
            
             <para>
             This enables you to temporarily add a temporary user to an existing <see cref="T:NReco.CF.Taste.Model.IDataModel"/> in a way that
             recommenders can then produce recommendations anyway.
             </para>
             </summary>
             <example>
            
             <code>
             IDataModel realModel = ...;
             IDataModel plusModel = new PlusAnonymousUserDataModel(realModel);
             ...
             var similarity = new LogLikelihoodSimilarity(realModel); // not plusModel
             </code>
            
             <para>
             But, you may continue to use <code>realModel</code> as input to other components. To recommend, first construct and
             set the temporary user information on the model and then simply call the recommender. The
             <code>lock</code> block exists to remind you that this is of course not thread-safe. Only one set
             of temp data can be inserted into the model and used at one time.
             </para>
            
             <code>
             IRecommender recommender = ...;
             ...
             lock(...) {
               IPreferenceArray tempPrefs = ...;
               plusModel.SetTempPrefs(tempPrefs);
               recommender.Recommend(PlusAnonymousUserDataModel.TEMP_USER_ID, 10);
               plusModel.SetTempPrefs(null);
             }
             </code>
             </example>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.tempPrefs">
            Preferences for all anonymous users 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.prefItemIDs">
            Item IDs set for all anonymous users 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.usersPool">
            Pool of the users (FIFO) 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.#ctor(NReco.CF.Taste.Model.IDataModel,System.Int32)">
            @param delegate Real model where anonymous users will be added to
            @param maxConcurrentUsers Maximum allowed number of concurrent anonymous users
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.initializeUsersPools(System.Int32)">
             Initialize the pool of concurrent anonymous users.
            
             @param usersPoolSize Maximum allowed number of concurrent anonymous user. Depends on the consumer system.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.TakeAvailableUser">
             Take the next available concurrent anonymous users from the pool.
            
             @return User ID or null if no more users are available
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.ReleaseUser(System.Int64)">
             Release previously taken anonymous user and return it to the pool.
            
             @param userID ID of a previously taken anonymous user
             @return true if the user was previously taken, false otherwise
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.isAnonymousUser(System.Int64)">
            Checks whether a given user is a valid previously acquired anonymous user.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.SetTempPrefs(NReco.CF.Taste.Model.IPreferenceArray,System.Int64)">
            Sets temporary preferences for a given anonymous user.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Model.PlusAnonymousConcurrentUserDataModel.ClearTempPrefs(System.Int64)">
            Clears temporary preferences for a given anonymous user.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Neighborhood.AbstractUserNeighborhood">
            <summary>
            Contains methods and resources useful to all classes in this package.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Neighborhood.IUserNeighborhood">
            <summary>
            Implementations of this interface compute a "neighborhood" of users like a given user. This neighborhood
            can be used to compute recommendations then.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Neighborhood.IUserNeighborhood.GetUserNeighborhood(System.Int64)">
            <summary>
            Get IDs of users in the neighborhood to specified user ID
            </summary>
            <param name="userID">ID of user for which a neighborhood will be computed</param>
            <returns>IDs of users in the neighborhood</returns>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Neighborhood.CachingUserNeighborhood">
            <summary>
            A caching wrapper around an underlying <see cref="T:NReco.CF.Taste.Neighborhood.IUserNeighborhood"/> implementation. 
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Neighborhood.NearestNUserNeighborhood">
            <summary>
            Computes a neighborhood consisting of the nearest n users to a given user. "Nearest" is defined by the
            given <see cref="T:NReco.CF.Taste.Similarity.IUserSimilarity"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NReco.CF.Taste.Impl.Neighborhood.NearestNUserNeighborhood.#ctor(System.Int32,NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.CF.Taste.Impl.Neighborhood.NearestNUserNeighborhood.#ctor(System.Int32,System.Double,NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel)" -->
        <!-- Badly formed XML comment ignored for member "M:NReco.CF.Taste.Impl.Neighborhood.NearestNUserNeighborhood.#ctor(System.Int32,System.Double,NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel,System.Double)" -->
        <member name="T:NReco.CF.Taste.Impl.Recommender.TopItems">
            <summary>
            A simple class that refactors the "find top N things" logic that is used in several places.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.TopItems.GetTopItemItemSimilarities(System.Int32,System.Collections.Generic.IEnumerator{NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity})">
            <p>
            Thanks to tsmorton for suggesting this functionality and writing part of the code.
            </p>
            
            @see GenericItemSimilarity#GenericItemSimilarity(Iterable, int)
            @see GenericItemSimilarity#GenericItemSimilarity(NReco.CF.Taste.Similarity.ItemSimilarity,
                 NReco.CF.Taste.Model.DataModel, int)
        </member>
        <member name="T:NReco.CF.Taste.Impl.Neighborhood.ThresholdUserNeighborhood">
            <summary>
            Computes a neigbhorhood consisting of all users whose similarity to the given user meets or exceeds a
            certain threshold. Similarity is defined by the given <see cref="T:NReco.CF.Taste.Similarity.IUserSimilarity"/>.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Neighborhood.ThresholdUserNeighborhood.#ctor(System.Double,NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel)">
            @param threshold
                     similarity threshold
            @param userSimilarity
                     similarity metric
            @param dataModel
                     data model
            @throws IllegalArgumentException
                      if threshold is {@link Double#NaN}, or if samplingRate is not positive and less than or equal
                      to 1.0, or if userSimilarity or dataModel are {@code null}
        </member>
        <member name="M:NReco.CF.Taste.Impl.Neighborhood.ThresholdUserNeighborhood.#ctor(System.Double,NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel,System.Double)">
            @param threshold
                     similarity threshold
            @param userSimilarity
                     similarity metric
            @param dataModel
                     data model
            @param samplingRate
                     percentage of users to consider when building neighborhood -- decrease to trade quality for
                     performance
            @throws IllegalArgumentException
                      if threshold or samplingRate is {@link Double#NaN}, or if samplingRate is not positive and less
                      than or equal to 1.0, or if userSimilarity or dataModel are {@code null}
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.AbstractCandidateItemsStrategy">
            <summary>
            Abstract base implementation for retrieving candidate items to recommend
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.ICandidateItemsStrategy">
            <summary>Used to retrieve all items that could possibly be recommended to the user</summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.ICandidateItemsStrategy.GetCandidateItems(System.Int64,NReco.CF.Taste.Model.IPreferenceArray,NReco.CF.Taste.Model.IDataModel)">
            <summary>
            Get IDs of all items that could be recommended to the user
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IMostSimilarItemsCandidateItemsStrategy">
            <summary>
            Used to retrieve all items that could possibly be similar
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IRecommender">
            <summary>
            Implementations of this interface can recommend items for a user. Implementations will likely take
            advantage of several classes in other packages here to compute this.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.Recommend(System.Int64,System.Int32)">
            <summary>
            Recommend desired number of items for given user ID
            </summary>
            <param name="userID">user for which recommendations are to be computed</param>
            <param name="howMany">desired number of recommendations</param>
            <returns><see cref="T:System.Collections.ICollection"/> of recommended <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/>s, ordered from most strongly recommend to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.Recommend(System.Int64,System.Int32,NReco.CF.Taste.Recommender.IDRescorer)">
            <summary>
            Recommend desired number of items for given user ID and rescorer
            </summary>
            <param name="userID">user for which recommendations are to be computed</param>
            <param name="howMany">desired number of recommendations</param>
            <param name="rescorer">rescoring function to apply before final list of recommendations is determined</param>
            <returns><see cref="!:List"/> of recommended <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/>s, ordered from most strongly recommend to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.EstimatePreference(System.Int64,System.Int64)">
            <summary>
            Estimate preference for given user ID and item ID
            </summary>
            <param name="userID">user ID whose preference is to be estimated</param>
            <param name="itemID">item ID to estimate preference for</param>
            <returns>
            an estimated preference if the user has not expressed a preference for the item, or else the
            user's actual preference for the item. If a preference cannot be estimated, returns Double.NaN
            </returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.SetPreference(System.Int64,System.Int64,System.Single)">
            <summary>
            Set preference value for given user ID and item ID
            </summary>
            <param name="userID">user to set preference for</param>
            <param name="itemID">item to set preference for</param>
            <param name="value">preference value</param>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.RemovePreference(System.Int64,System.Int64)">
            <summary>
            Remove preferense for given user ID and item ID
            </summary>
            <param name="userID">user from which to remove preference</param>
            <param name="itemID">item for which to remove preference</param>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommender.GetDataModel">
            <summary>
            Get underlying data model instance
            </summary>
            <returns>underlying <see cref="T:NReco.CF.Taste.Model.IDataModel"/> used by this <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> implementation</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.AbstractRecommender.Recommend(System.Int64,System.Int32)">
            <p>
            Default implementation which just calls
            {@link Recommender#recommend(long, int, NReco.CF.Taste.Recommender.IDRescorer)}, with a
            {@link NReco.CF.Taste.Recommender.Rescorer} that does nothing.
            </p>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.AbstractRecommender.SetPreference(System.Int64,System.Int64,System.Single)">
             <p>
             Default implementation which just calls {@link DataModel#setPreference(long, long, float)}.
             </p>
            
             @throws IllegalArgumentException
                       if userID or itemID is {@code null}, or if value is {@link Double#NaN}
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.AbstractRecommender.RemovePreference(System.Int64,System.Int64)">
             <p>
             Default implementation which just calls {@link DataModel#removePreference(long, long)} (Object, Object)}.
             </p>
            
             @throws IllegalArgumentException
                       if userID or itemID is {@code null}
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.AbstractRecommender.GetAllOtherItems(System.Int64,NReco.CF.Taste.Model.IPreferenceArray)">
            @param userID
                     ID of user being evaluated
            @param preferencesFromUser
                     the preferences from the user
            @return all items in the {@link DataModel} for which the user has not expressed a preference and could
                    possibly be recommended to the user
            @throws TasteException
                      if an error occurs while listing items
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.AllSimilarItemsCandidateItemsStrategy">
            <summary>
            Returns the result of <see cref="M:NReco.CF.Taste.Similarity.IItemSimilarity.AllSimilarItemIDs(System.Int64)"/> as candidate items
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.AllUnknownItemsCandidateItemsStrategy">
            <summary>
            Return all items the user has not yet seen
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.ByRescoreComparator">
            <summary>
            Defines ordering on <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/> by the rescored value of the recommendations' estimated
            preference value, from high to low.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.ByValueRecommendedItemComparator">
            <summary>Defines a natural ordering from most-preferred item (highest value) to least-preferred.</summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.CachingRecommender">
            <summary>
            A <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> which caches the results from another <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> in memory.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.CachingRecommender.clear(System.Int64)">
            <p>
            Clears cached recommendations for the given user.
            </p>
            
            @param userID
                     clear cached data associated with this user ID
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.CachingRecommender.clear">
            <p>
            Clears all cached recommendations.
            </p>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.EstimatedPreferenceCapper">
            <summary>
            Simple class which encapsulates restricting a preference value
            to a predefined range. The simple logic is wrapped up here for
            performance reasons.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.GenericBooleanPrefItemBasedRecommender">
            <summary>
            A variant on <see cref="T:NReco.CF.Taste.Impl.Recommender.GenericItemBasedRecommender"/> which is appropriate for use when no notion of preference
            value exists in the data.
            </summary>
            <seealso cref="T:NReco.CF.Taste.Impl.Recommender.GenericBooleanPrefUserBasedRecommender"/>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.GenericItemBasedRecommender">
            <summary>
            <para>
            A simple <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> which uses a given
            <see cref="T:NReco.CF.Taste.Model.IDataModel"/> and
            <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/> to produce recommendations. This class
            represents Taste's support for item-based recommenders.
            </para>
            
            <para>
            The <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/> is the most important point to discuss
            here. Item-based recommenders are useful because they can take advantage of something to be very fast: they
            base their computations on item similarity, not user similarity, and item similarity is relatively static.
            It can be precomputed, instead of re-computed in real time.
            </para>
            
            <para>
            Thus it's strongly recommended that you use
            <see cref="T:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity"/> with pre-computed similarities if
            you're going to use this class. You can use
            <see cref="T:NReco.CF.Taste.Impl.Similarity.PearsonCorrelationSimilarity"/> too, which computes
            similarities in real-time, but will probably find this painfully slow for large amounts of data.
            </para>
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IItemBasedRecommender">
            <summary>
            Interface implemented by "item-based" recommenders.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64,System.Int32)">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemID">ID of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find</param>
            <returns>items most similar to the given item, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64,System.Int32,NReco.CF.Taste.Recommender.IRescorer{System.Tuple{System.Int64,System.Int64}})">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemID">ID of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find</param>
            <param name="rescorer"><see cref="!:IRescorer"/> which can adjust item-item similarity estimates used to determine most similar items</param>
            <returns>items most similar to the given item, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64[],System.Int32)">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemIDs">IDs of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find estimates used to determine most similar items</param>
            <returns>items most similar to the given items, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64[],System.Int32,NReco.CF.Taste.Recommender.IRescorer{System.Tuple{System.Int64,System.Int64}})">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemIDs">IDs of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find</param>
            <param name="rescorer"><see cref="!:IRescorer"/> which can adjust item-item similarity estimates used to determine most similar items</param>
            <returns>items most similar to the given items, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64[],System.Int32,System.Boolean)">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemIDs">IDs of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find</param>
            <param name="excludeItemIfNotSimilarToAll">exclude an item if it is not similar to each of the input items</param>
            <returns>items most similar to the given items, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.MostSimilarItems(System.Int64[],System.Int32,NReco.CF.Taste.Recommender.IRescorer{System.Tuple{System.Int64,System.Int64}},System.Boolean)">
            <summary>
            Get list of most similar items
            </summary>
            <param name="itemIDs">IDs of item for which to find most similar other items</param>
            <param name="howMany">desired number of most similar items to find</param>
            <param name="rescorer">{@link Rescorer} which can adjust item-item similarity estimates used to determine most similar items</param>
            <param name="excludeItemIfNotSimilarToAll">exclude an item if it is not similar to each of the input items</param>
            <returns>items most similar to the given items, ordered from most similar to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IItemBasedRecommender.RecommendedBecause(System.Int64,System.Int64,System.Int32)">
            <summary>
            Lists the items that were most influential in recommending a given item to a given user. Exactly how this
            is determined is left to the implementation, but, generally this will return items that the user prefers
            and that are similar to the given item.
            <para>
            This returns a <see cref="!:List"/> of <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/> which is a little misleading since it's returning
            recommend<strong>ing</strong> items, but, I thought it more natural to just reuse this class since it
            encapsulates an item and value. The value here does not necessarily have a consistent interpretation or
            expected range; it will be higher the more influential the item was in the recommendation. 
            </para>
            </summary>
            <param name="userID">ID of user who was recommended the item</param>
            <param name="itemID">ID of item that was recommended</param>
            <param name="howMany">maximum number of items to return</param>
            <returns><see cref="!:List"/> of <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/>, ordered from most influential in recommended the given item to least</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.GenericBooleanPrefItemBasedRecommender.doEstimatePreference(System.Int64,NReco.CF.Taste.Model.IPreferenceArray,System.Int64)">
            This computation is in a technical sense, wrong, since in the domain of "bool preference users" where
            all preference values are 1, this method should only ever return 1.0 or NaN. This isn't terribly useful
            however since it means results can't be ranked by preference value (all are 1). So instead this returns a
            sum of similarities.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.GenericBooleanPrefUserBasedRecommender">
            <summary>
            A variant on <see cref="T:NReco.CF.Taste.Impl.Recommender.GenericUserBasedRecommender"/> which is appropriate for use when no notion of preference
            value exists in the data.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.GenericUserBasedRecommender">
            <summary>
            A simple <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/>
            which uses a given <see cref="T:NReco.CF.Taste.Model.IDataModel"/> and <see cref="T:NReco.CF.Taste.Neighborhood.IUserNeighborhood"/> to produce recommendations.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IUserBasedRecommender">
            <summary>
            Interface implemented by "user-based" recommenders.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IUserBasedRecommender.MostSimilarUserIDs(System.Int64,System.Int32)">
            <summary>
            Get most similar user IDs for specified user ID
            </summary>
            <param name="userID">ID of user for which to find most similar other users</param>
            <param name="howMany">desired number of most similar users to find</param>
            <returns>users most similar to the given user</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IUserBasedRecommender.MostSimilarUserIDs(System.Int64,System.Int32,NReco.CF.Taste.Recommender.IRescorer{System.Tuple{System.Int64,System.Int64}})">
            <summary>
            Get most similar user IDs for specified user ID and rescorer
            </summary>
            <param name="userID">ID of user for which to find most similar other users</param>
            <param name="howMany">desired number of most similar users to find</param>
            <param name="rescorer"><see cref="!:IRescorer"/> which can adjust user-user similarity estimates used to determine most similar users</param>
            <returns>IDs of users most similar to the given user</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.GenericBooleanPrefUserBasedRecommender.doEstimatePreference(System.Int64,System.Int64[],System.Int64)">
            This computation is in a technical sense, wrong, since in the domain of "bool preference users" where
            all preference values are 1, this method should only ever return 1.0 or NaN. This isn't terribly useful
            however since it means results can't be ranked by preference value (all are 1). So instead this returns a
            sum of similarities to any other user in the neighborhood who has also rated the item.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.GenericRecommendedItem">
            <summary>
            A simple implementation of <see cref="T:NReco.CF.Taste.Recommender.IRecommendedItem"/>.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IRecommendedItem">
            <summary>
            Implementations encapsulate items that are recommended, and include the item recommended and a value
            expressing the strength of the preference.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommendedItem.GetItemID">
            <summary>
            Item ID
            </summary>
            <returns>the recommended item ID </returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRecommendedItem.GetValue">
            <summary>
            A value expressing the strength of the preference for the recommended item. The range of the values
            depends on the implementation. Implementations must use larger values to express stronger preference.
            </summary>
            <returns>strength of the preference</returns>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.GenericRecommendedItem.#ctor(System.Int64,System.Single)">
            @throws IllegalArgumentException
                      if item is null or value is NaN
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.ItemAverageRecommender">
            <summary>
            A simple recommender that always estimates preference for an item to be the average of all known preference
            values for that item. No information about users is taken into account. This implementation is provided for
            experimentation; while simple and fast, it may not produce very good recommendations.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.ItemUserAverageRecommender">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Recommender.ItemAverageRecommender"/>, except that estimated preferences are adjusted for the users' average
            preference value. For example, say user X has not rated item Y. Item Y's average preference value is 3.5.
            User X's average preference value is 4.2, and the average over all preference values is 4.0. User X prefers
            items 0.2 higher on average, so, the estimated preference for user X, item Y is 3.5 + 0.2 = 3.7.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.NullRescorer`1">
            <summary>
            A simple <see cref="!:IRescorer"/> which always returns the original score.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IRescorer`1">
            <summary>
            A IRescorer simply assigns a new "score" to a thing like an ID of an item or user which a
            {@link Recommender} is considering returning as a top recommendation. It may be used to arbitrarily re-rank
            the results according to application-specific logic before returning recommendations. For example, an
            application may want to boost the score of items in a certain category just for one request.
            <para>
            A <see cref="!:IRescorer"/> can also exclude a thing from consideration entirely by returning <code>true</code> from
            <see cref="!:IRescorer.isFiltered"/>.
            </para>
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRescorer`1.Rescore(`0,System.Double)">
            <summary>
            Calculate new score for given thing and its original score
            </summary>
            <param name="thing">thing to rescore</param>
            <param name="originalScore">original score</param>
            <returns>modified score, or {@link Double#NaN} to indicate that this should be excluded entirely</returns>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IRescorer`1.IsFiltered(`0)">
            <summary>
            Returns <code>true</code> to exclude the given thing.
            </summary>
            <param name="thing">the thing to filter</param>
            <returns><code>true</code> to exclude, <code>false</code> otherwise</returns>
        </member>
        <member name="T:NReco.CF.Taste.Recommender.IDRescorer">
            <p>
            A {@link Rescorer} which operates on {@code long} primitive IDs, rather than arbitrary {@link Object}s.
            This is provided since most uses of this interface in the framework take IDs (as {@code long}) as an
            argument, and so this can be used to avoid unnecessary boxing/unboxing.
            </p>
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IDRescorer.rescore(System.Int64,System.Double)">
            @param id
                     ID of thing (user, item, etc.) to rescore
            @param originalScore
                     original score
            @return modified score, or {@link Double#NaN} to indicate that this should be excluded entirely
        </member>
        <member name="M:NReco.CF.Taste.Recommender.IDRescorer.isFiltered(System.Int64)">
             Returns {@code true} to exclude the given thing.
            
             @param id
                      ID of thing (user, item, etc.) to rescore
             @return {@code true} to exclude, {@code false} otherwise
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.NullRescorer`1.Rescore(`0,System.Double)">
            @param thing
                     to rescore
            @param originalScore
                     current score for item
            @return same originalScore as new score, always
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.PreferredItemsNeighborhoodCandidateItemsStrategy">
            <summary>
            Returns all items that have not been rated by the user and that were preferred by another user
            that has preferred at least one item that the current user has preferred too.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.RandomRecommender">
            <summary>
            Produces random recommendations and preference estimates. This is likely only useful as a novelty and for benchmarking.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy">
             <summary>
             <para>Returns all items that have not been rated by the user <em>(3)</em> and that were preferred by another user
             <em>(2)</em> that has preferred at least one item <em>(1)</em> that the current user has preferred too.</para>
            
             <para>This strategy uses sampling to limit the number of items that are considered, by sampling three different
             things, noted above:</para>
             <ol>
               <li>The items that the user has preferred</li>
               <li>The users who also prefer each of those items</li>
               <li>The items those users also prefer</li>
             </ol>
             
             <para>There is a maximum associated with each of these three things; if the number of items or users exceeds
             that max, it is sampled so that the expected number of items or users actually used in that part of the
             computation is equal to the max.</para>
             
             <para>Three arguments control these three maxima. Each is a "factor" f, which establishes the max at
             f * log2(n), where n is the number of users or items in the data. For example if factor #2 is 5,
             which controls the number of users sampled per item, then 5 * log2(# users) is the maximum for this
             part of the computation.</para>
             
             <para>Each can be set to not do any limiting with value <see cref="F:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy.NO_LIMIT_FACTOR"/>.</para>
             </summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy.DEFAULT_FACTOR">
            Default factor used if not otherwise specified, for all limits. (30).
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy.NO_LIMIT_FACTOR">
            Specify this value as a factor to mean no limit.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy.#ctor(System.Int32,System.Int32)">
             Defaults to using no limit ({@link #NO_LIMIT_FACTOR}) for all factors, except 
             {@code candidatesPerUserFactor} which defaults to {@link #DEFAULT_FACTOR}.
            
             @see #SamplingCandidateItemsStrategy(int, int, int, int, int)
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SamplingCandidateItemsStrategy.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            @param itemsFactor factor controlling max items considered for a user
            @param usersPerItemFactor factor controlling max users considered for each of those items
            @param candidatesPerUserFactor factor controlling max candidate items considered from each of those users
            @param numUsers number of users currently in the data
            @param numItems number of items in the data
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SimilarUser">
            <summary>Simply encapsulates a user and a similarity value. </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SimilarUser.CompareTo(NReco.CF.Taste.Impl.Recommender.SimilarUser)">
            Defines an ordering from most similar to least similar. 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.Factorization">
            <summary>
            A factorization of the rating matrix
            </summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.Factorization.userIDMapping">
            used to find the rows in the user features matrix by userID 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.Factorization.itemIDMapping">
            used to find the rows in the item features matrix by itemID 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.Factorization.userFeatures">
            user features matrix 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.Factorization.itemFeatures">
            item features matrix 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.NoPersistenceStrategy">
            <summary>A <see cref="T:NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy"/> which does nothing.</summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer">
            <summary>
            Minimalistic implementation of Parallel SGD factorizer based on
            <a href="http://www.sze.hu/~gtakacs/download/jmlr_2009.pdf">
            "Scalable Collaborative Filtering Approaches for Large Recommender Systems"</a>
            and
            <a href="hwww.cs.wisc.edu/~brecht/papers/hogwildTR.pdf">
            "Hogwild!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent"</a> 
            </summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.lambda">
            Parameter used to prevent overfitting. 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.rank">
            Number of features used to compute this factorization 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.numEpochs">
            Number of iterations 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.userVectors">
            TODO: this is not safe as += is not atomic on many processors, can be replaced with AtomicDoubleArray
            but it works just fine right now  
            user features 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.itemVectors">
            item features 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.USER_BIAS_INDEX">
            place in user vector where the bias is stored 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.ITEM_BIAS_INDEX">
            place in item vector where the bias is stored 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.NOISE">
            Standard deviation for random initialization of features 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.ParallelSGDFactorizer.update(NReco.CF.Taste.Model.IPreference,System.Double)">
             TODO: this is the vanilla sgd by Tacaks 2009, I speculate that using scaling technique proposed in:
             Towards Optimal One Pass Large Scale Learning with Averaged Stochastic Gradient Descent section 5, page 6
             can be beneficial in term s of both speed and accuracy.
            
             Tacaks' method doesn't calculate gradient of regularization correctly, which has non-zero elements everywhere of
             the matrix. While Tacaks' method can only updates a single row/column, if one user has a lot of recommendation,
             her vector will be more affected by regularization using an isolated scaling factor for both user vectors and
             item vectors can remove this issue without inducing more update cost it even reduces it a bit by only performing
             one addition and one multiplication.
            
             BAD SIDE1: the scaling factor decreases fast, it has to be scaled up from time to time before dropped to zero or
                        caused roundoff error
             BAD SIDE2: no body experiment on it before, and people generally use very small lambda
                        so it's impact on accuracy may still be unknown.
             BAD SIDE3: don't know how to make it work for L1-regularization or
                        "pseudorank?" (sum of singular values)-regularization 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer">
            <summary>Matrix factorization with user and item biases for rating prediction, trained with plain vanilla SGD </summary>
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.learningRateDecay">
            Multiplicative decay factor for learning_rate 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.learningRate">
            Learning rate (step size) 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.preventOverfitting">
            Parameter used to prevent overfitting. 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.numFeatures">
            Number of features used to compute this factorization 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.numIterations">
            Number of iterations 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.randomNoise">
            Standard deviation for random initialization of features 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.userVectors">
            User features 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.itemVectors">
            Item features 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.USER_BIAS_INDEX">
            place in user vector where the bias is stored 
        </member>
        <member name="F:NReco.CF.Taste.Impl.Recommender.SVD.RatingSGDFactorizer.ITEM_BIAS_INDEX">
            place in item vector where the bias is stored 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.SVDPlusPlusFactorizer">
             <summary>
             SVD++, an enhancement of classical matrix factorization for rating prediction.
             Additionally to using ratings (how did people rate?) for learning, this model also takes into account
             who rated what.
            
             Yehuda Koren: Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model, KDD 2008.
             http://research.yahoo.com/files/kdd08koren.pdf
             </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Recommender.SVD.SVDRecommender">
            <summary>
            A <see cref="T:NReco.CF.Taste.Recommender.IRecommender"/> that uses matrix factorization (a projection of users
            and items onto a feature space)
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.SVDRecommender.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Impl.Recommender.SVD.IFactorizer,NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy)">
             Create an SVDRecommender using a persistent store to cache factorizations. A factorization is loaded from the
             store if present, otherwise a new factorization is computed and saved in the store.
            
             The {@link #refresh(java.util.Collection) refresh} method recomputes the factorization and overwrites the store.
            
             @param dataModel
             @param factorizer
             @param persistenceStrategy
             @throws TasteException
             @throws IOException
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.SVDRecommender.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Impl.Recommender.SVD.IFactorizer,NReco.CF.Taste.Recommender.ICandidateItemsStrategy,NReco.CF.Taste.Impl.Recommender.SVD.IPersistenceStrategy)">
             Create an SVDRecommender using a persistent store to cache factorizations. A factorization is loaded from the
             store if present, otherwise a new factorization is computed and saved in the store. 
            
             The {@link #refresh(java.util.Collection) refresh} method recomputes the factorization and overwrites the store.
            
             @param dataModel
             @param factorizer
             @param candidateItemsStrategy
             @param persistenceStrategy
            
             @throws TasteException
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.SVDRecommender.EstimatePreference(System.Int64,System.Int64)">
            a preference is estimated by computing the dot-product of the user and item feature vectors
        </member>
        <member name="M:NReco.CF.Taste.Impl.Recommender.SVD.SVDRecommender.Refresh(System.Collections.Generic.IList{NReco.CF.Taste.Common.IRefreshable})">
            Refresh the data model and factorization.
        </member>
        <member name="T:NReco.CF.Taste.Similarity.IItemSimilarity">
            <summary>
            Implementations of this interface define a notion of similarity between two items. Implementations should
            return values in the range -1.0 to 1.0, with 1.0 representing perfect similarity.
            </summary>
            <see cref="T:NReco.CF.Taste.Similarity.IUserSimilarity"/>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IItemSimilarity.ItemSimilarity(System.Int64,System.Int64)">
            <summary>
            Returns the degree of similarity, of two items, based on the preferences that users have expressed for
            the items.
            </summary>
            <param name="itemID1">first item ID</param>
            <param name="itemID2">second item ID</param>
            <returns>similarity between the items, in [-1,1] or {@link Double#NaN} similarity is unknown</returns>
            <remarks>
            Throws NReco.CF.Taste.Common.NoSuchItemException if either item is known to be non-existent in the data.
            Throws TasteException if an error occurs while accessing the data.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IItemSimilarity.ItemSimilarities(System.Int64,System.Int64[])">
            <summary>
            A bulk-get version of <see cref="M:NReco.CF.Taste.Similarity.IItemSimilarity.ItemSimilarity(System.Int64,System.Int64)"/>.
            </summary>
            <param name="itemID1">first item ID</param>
            <param name="itemID2s">second item IDs to compute similarity with</param>
            <returns>similarity between itemID1 and other items</returns>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IItemSimilarity.AllSimilarItemIDs(System.Int64)">
            <summary>
            Return all similar item IDs
            </summary>
            <returns>all IDs of similar items, in no particular order</returns>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.AbstractSimilarity">
            <summary>Abstract superclass encapsulating functionality that is common to most implementations in this package. </summary>
        </member>
        <member name="T:NReco.CF.Taste.Similarity.IUserSimilarity">
            <summary>
            Implementations of this interface define a notion of similarity between two users. Implementations should
            return values in the range -1.0 to 1.0, with 1.0 representing perfect similarity.
            </summary>
            <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IUserSimilarity.UserSimilarity(System.Int64,System.Int64)">
            <summary>
            Returns the degree of similarity, of two users, based on the their preferences.
            </summary>
            <param name="userID1">first user ID</param>
            <param name="userID2">second user ID</param>
            <returns>similarity between the users, in [-1,1] or Double.NaN if similarity is unknown</returns>
            <remarks>
            Throws NReco.CF.Taste.Common.NoSuchUserException if either user is known to be non-existent in the data.
            Throws TasteException if an error occurs while accessing the data.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IUserSimilarity.SetPreferenceInferrer(NReco.CF.Taste.Similarity.IPreferenceInferrer)">
            <summary>
            Attaches a <see cref="T:NReco.CF.Taste.Similarity.IPreferenceInferrer"/> to the <see cref="T:NReco.CF.Taste.Similarity.IUserSimilarity"/> implementation.
            </summary>
            <param name="inferrer">inferrer to set</param>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.AbstractSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Common.Weighting,System.Boolean)">
            <p>
            Creates a possibly weighted {@link AbstractSimilarity}.
            </p>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.AbstractSimilarity.computeResult(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <p>
            Several subclasses in this package implement this method to actually compute the similarity from figures
            computed over users or items. Note that the computations in this class "center" the data, such that X and
            Y's mean are 0.
            </p>
            
            <p>
            Note that the sum of all X and Y values must then be 0. This value isn't passed down into the standard
            similarity computations as a result.
            </p>
            
            @param n
                     total number of users or items
            @param sumXY
                     sum of product of user/item preference values, over all items/users preferred by both
                     users/items
            @param sumX2
                     sum of the square of user/item preference values, over the first item/user
            @param sumY2
                     sum of the square of the user/item preference values, over the second item/user
            @param sumXYdiff2
                     sum of squares of differences in X and Y values
            @return similarity value between -1.0 and 1.0, inclusive, or {@link Double#NaN} if no similarity can be
                    computed (e.g. when no items have been rated by both users
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.AveragingPreferenceInferrer">
            <summary>
            Implementations of this interface compute an inferred preference for a user and an item that the user has
            not expressed any preference for. This might be an average of other preferences scores from that user, for
            example. This technique is sometimes called "default voting".
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Similarity.IPreferenceInferrer">
            <summary>
            Implementations of this interface compute an inferred preference for a user and an item that the user has
            not expressed any preference for. This might be an average of other preferences scores from that user, for
            example. This technique is sometimes called "default voting".
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Similarity.IPreferenceInferrer.InferPreference(System.Int64,System.Int64)">
            <summary>
            Infers the given user's preference value for an item.
            </summary>
            <param name="userID">ID of user to infer preference for</param>
            <param name="itemID">item ID to infer preference for</param>
            <returns>inferred preference</returns>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.CachingItemSimilarity">
            <summary>Caches the results from an underlying <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/> implementation.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CachingItemSimilarity.#ctor(NReco.CF.Taste.Similarity.IItemSimilarity,NReco.CF.Taste.Model.IDataModel)">
            Creates this on top of the given {@link ItemSimilarity}.
            The cache is sized according to properties of the given {@link DataModel}.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CachingItemSimilarity.#ctor(NReco.CF.Taste.Similarity.IItemSimilarity,System.Int32)">
            Creates this on top of the given {@link ItemSimilarity}.
            The cache size is capped by the given size.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.CachingUserSimilarity">
            <summary>Caches the results from an underlying <see cref="T:NReco.CF.Taste.Similarity.IUserSimilarity"/> implementation.</summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CachingUserSimilarity.#ctor(NReco.CF.Taste.Similarity.IUserSimilarity,NReco.CF.Taste.Model.IDataModel)">
            Creates this on top of the given {@link UserSimilarity}.
            The cache is sized according to properties of the given {@link DataModel}.
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CachingUserSimilarity.#ctor(NReco.CF.Taste.Similarity.IUserSimilarity,System.Int32)">
            Creates this on top of the given {@link UserSimilarity}.
            The cache size is capped by the given size.
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.CityBlockSimilarity">
            <summary>
            Implementation of City Block distance (also known as Manhattan distance) - the absolute value of the difference of
            each direction is summed.  The resulting unbounded distance is then mapped between 0 and 1.
            </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CityBlockSimilarity.SetPreferenceInferrer(NReco.CF.Taste.Similarity.IPreferenceInferrer)">
            @throws NotSupportedException
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.CityBlockSimilarity.doSimilarity(System.Int32,System.Int32,System.Int32)">
             Calculate City Block Distance from total non-zero values and intersections and map to a similarity value.
            
             @param pref1        number of non-zero values in left vector
             @param pref2        number of non-zero values in right vector
             @param intersection number of overlapping non-zero values
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.EuclideanDistanceSimilarity">
             <summary>
             <para>An implementation of a "similarity" based on the Euclidean "distance" between two users X and Y. Thinking
             of items as dimensions and preferences as points along those dimensions, a distance is computed using all
             items (dimensions) where both users have expressed a preference for that item. This is simply the square
             root of the sum of the squares of differences in position (preference) along each dimension.
             </para>
             
             <para>The similarity could be computed as 1 / (1 + distance), so the resulting values are in the range (0,1].
             This would weight against pairs that overlap in more dimensions, which should indicate more similarity, 
             since more dimensions offer more opportunities to be farther apart. Actually, it is computed as 
             sqrt(n) / (1 + distance), where n is the number of dimensions, in order to help correct for this.
             sqrt(n) is chosen since randomly-chosen points have a distance that grows as sqrt(n).</para>
            
             <para>Note that this could cause a similarity to exceed 1; such values are capped at 1.</para>
             
             <para>Note that the distance isn't normalized in any way; it's not valid to compare similarities computed from
             different domains (different rating scales, for example). Within one domain, normalizing doesn't matter much as
             it doesn't change ordering.
             </para>
             </summary>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.EuclideanDistanceSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.EuclideanDistanceSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Common.Weighting)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity">
            <summary>
            A "generic" <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/> which takes a static list of precomputed item similarities and bases its
            responses on that alone. The values may have been precomputed offline by another process, stored in a file,
            and then read and fed into an instance of this class.
            </summary>
            <remarks>
            This is perhaps the best <see cref="T:NReco.CF.Taste.Similarity.IItemSimilarity"/> to use with
            <see cref="T:NReco.CF.Taste.Impl.Recommender.GenericItemBasedRecommender"/>, for now, since the point
            of item-based recommenders is that they can take advantage of the fact that item similarity is relatively
            static, can be precomputed, and then used in computation to gain a significant performance advantage.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.#ctor(System.Collections.Generic.IEnumerable{NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity})">
             <p>
             Creates a {@link GenericItemSimilarity} from a precomputed list of {@link ItemItemSimilarity}s. Each
             represents the similarity between two distinct items. Since similarity is assumed to be symmetric, it is
             not necessary to specify similarity between item1 and item2, and item2 and item1. Both are the same. It
             is also not necessary to specify a similarity between any item and itself; these are assumed to be 1.0.
             </p>
            
             <p>
             Note that specifying a similarity between two items twice is not an error, but, the later value will win.
             </p>
            
             @param similarities
                      set of {@link ItemItemSimilarity}s on which to base this instance
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.#ctor(System.Collections.Generic.IEnumerable{NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity},System.Int32)">
            <p>
            Like {@link #GenericItemSimilarity(Iterable)}, but will only keep the specified number of similarities
            from the given {@link Iterable} of similarities. It will keep those with the highest similarity -- those
            that are therefore most important.
            </p>
            
            <p>
            Thanks to tsmorton for suggesting this and providing part of the implementation.
            </p>
            
            @param similarities
                     set of {@link ItemItemSimilarity}s on which to base this instance
            @param maxToKeep
                     maximum number of similarities to keep
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.#ctor(NReco.CF.Taste.Similarity.IItemSimilarity,NReco.CF.Taste.Model.IDataModel)">
            <p>
            Builds a list of item-item similarities given an {@link ItemSimilarity} implementation and a
            {@link DataModel}, rather than a list of {@link ItemItemSimilarity}s.
            </p>
            
            <p>
            It's valid to build a {@link GenericItemSimilarity} this way, but perhaps missing some of the point of an
            item-based recommender. Item-based recommenders use the assumption that item-item similarities are
            relatively fixed, and might be known already independent of user preferences. Hence it is useful to
            inject that information, using {@link #GenericItemSimilarity(Iterable)}.
            </p>
            
            @param otherSimilarity
                     other {@link ItemSimilarity} to get similarities from
            @param dataModel
                     data model to get items from
            @throws TasteException
                      if an error occurs while accessing the {@link DataModel} items
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.#ctor(NReco.CF.Taste.Similarity.IItemSimilarity,NReco.CF.Taste.Model.IDataModel,System.Int32)">
            <p>
            Like {@link #GenericItemSimilarity(ItemSimilarity, DataModel)} )}, but will only keep the specified
            number of similarities from the given {@link DataModel}. It will keep those with the highest similarity
            -- those that are therefore most important.
            </p>
            
            <p>
            Thanks to tsmorton for suggesting this and providing part of the implementation.
            </p>
            
            @param otherSimilarity
                     other {@link ItemSimilarity} to get similarities from
            @param dataModel
                     data model to get items from
            @param maxToKeep
                     maximum number of similarities to keep
            @throws TasteException
                      if an error occurs while accessing the {@link DataModel} items
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemSimilarity(System.Int64,System.Int64)">
             <p>
             Returns the similarity between two items. Note that similarity is assumed to be symmetric, that
             {@code itemSimilarity(item1, item2) == itemSimilarity(item2, item1)}, and that
             {@code itemSimilarity(item1,item1) == 1.0} for all items.
             </p>
            
             @param itemID1
                      first item
             @param itemID2
                      second item
             @return similarity between the two
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity">
            Encapsulates a similarity between two items. Similarity must be in the range [-1.0,1.0]. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity.#ctor(System.Int64,System.Int64,System.Double)">
            @param itemID1
                     first item
            @param itemID2
                     second item
            @param value
                     similarity between the two
            @throws IllegalArgumentException
                      if value is NaN, less than -1.0 or greater than 1.0
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity.CompareTo(NReco.CF.Taste.Impl.Similarity.GenericItemSimilarity.ItemItemSimilarity)">
            Defines an ordering from highest similarity to lowest. 
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.GenericUserSimilarity.UserUserSimilarity.CompareTo(NReco.CF.Taste.Impl.Similarity.GenericUserSimilarity.UserUserSimilarity)">
            Defines an ordering from highest similarity to lowest. 
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.LogLikelihoodSimilarity">
            <summary>
            Similarity test is based on the likelihood ratio, which expresses how many times more likely the data are under one model than the other.
            </summary>
            <remarks>
            See <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962">
            http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962</a> and
            <a href="http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html">
            http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html</a>.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.LogLikelihoodSimilarity.SetPreferenceInferrer(NReco.CF.Taste.Similarity.IPreferenceInferrer)">
            @throws NotSupportedException
        </member>
        <!-- Badly formed XML comment ignored for member "T:NReco.CF.Taste.Impl.Similarity.LongPairMatchPredicate" -->
        <member name="T:NReco.CF.Taste.Impl.Similarity.PearsonCorrelationSimilarity">
             <summary>
             An implementation of the Pearson correlation. 
             </summary>
             <remarks>
             For users X and Y, the following values are calculated:
             <ul>
             <li>sumX2: sum of the square of all X's preference values</li>
             <li>sumY2: sum of the square of all Y's preference values</li>
             <li>sumXY: sum of the product of X and Y's preference value for all items for which both X and Y express a
             preference</li>
             </ul>
             The correlation is then:
            
             <para>
             <code> sumXY / sqrt(sumX2 * sumY2) </code>
             </para>
            
             <para>
             Note that this correlation "centers" its data, shifts the user's preference values so that each of their
             means is 0. This is necessary to achieve expected behavior on all data sets.
             </para>
            
             <para>
             This correlation implementation is equivalent to the cosine similarity since the data it receives
             is assumed to be centered -- mean is 0. The correlation may be interpreted as the cosine of the angle
             between the two vectors defined by the users' preference values.
             </para>
            
             <para>
             For cosine similarity on uncentered data, see <see cref="T:NReco.CF.Taste.Impl.Similarity.UncenteredCosineSimilarity"/>.
             </para> 
             </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.PearsonCorrelationSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.PearsonCorrelationSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Common.Weighting)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.SpearmanCorrelationSimilarity">
            <summary>
            Like <see cref="T:NReco.CF.Taste.Impl.Similarity.PearsonCorrelationSimilarity"/>, but compares relative ranking of preference values instead of
            preference values themselves. That is, each user's preferences are sorted and then assign a rank as their
            preference value, with 1 being assigned to the least preferred item.
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.TanimotoCoefficientSimilarity">
            <summary>
            An implementation of a "similarity" based on the <a
            href="http://en.wikipedia.org/wiki/Jaccard_index#Tanimoto_coefficient_.28extended_Jaccard_coefficient.29">
            Tanimoto coefficient</a>, or extended <a href="http://en.wikipedia.org/wiki/Jaccard_index">Jaccard
            coefficient</a>.
            </summary>
            <remarks>
            <para>
            This is intended for "binary" data sets where a user either expresses a generic "yes" preference for an
            item or has no preference. The actual preference values do not matter here, only their presence or absence.
            </para>
            
            <para>
            The value returned is in [0,1].
            </para>
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.TanimotoCoefficientSimilarity.SetPreferenceInferrer(NReco.CF.Taste.Similarity.IPreferenceInferrer)">
            @throws NotSupportedException
        </member>
        <member name="T:NReco.CF.Taste.Impl.Similarity.UncenteredCosineSimilarity">
            <summary>
            An implementation of the cosine similarity. The result is the cosine of the angle formed between
            the two preference vectors.
            </summary>
            <remarks>
            Note that this similarity does not "center" its data, shifts the user's preference values so that each of their
            means is 0. For this behavior, use {@link PearsonCorrelationSimilarity}, which actually is mathematically
            equivalent for centered data.
            </remarks>
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.UncenteredCosineSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="M:NReco.CF.Taste.Impl.Similarity.UncenteredCosineSimilarity.#ctor(NReco.CF.Taste.Model.IDataModel,NReco.CF.Taste.Common.Weighting)">
            @{@link DataModel} does not have preference values
        </member>
        <member name="M:NReco.CF.Taste.Similarity.Precompute.BatchItemSimilarities.#ctor(NReco.CF.Taste.Recommender.IItemBasedRecommender,System.Int32)">
            @param recommender recommender to use
            @param similarItemsPerItem number of similar items to compute per item
        </member>
        <member name="M:NReco.CF.Taste.Similarity.Precompute.BatchItemSimilarities.computeItemSimilarities(System.Int32,System.Int32,NReco.CF.Taste.Similarity.Precompute.ISimilarItemsWriter)">
            @param degreeOfParallelism number of threads to use for the computation
            @param maxDurationInHours  maximum duration of the computation
            @param writer  {@link SimilarItemsWriter} used to persist the results
            @return  the number of similarities precomputed
            @throws IOException
            @throws RuntimeException if the computation takes longer than maxDurationInHours
        </member>
        <member name="T:NReco.CF.Taste.Similarity.Precompute.ISimilarItemsWriter">
            <summary>
            Used to persist the results of a batch item similarity computation
            conducted with a <see cref="T:NReco.CF.Taste.Similarity.Precompute.BatchItemSimilarities"/> implementation
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Similarity.Precompute.SimilarItem">
            <summary>
            Modeling similarity towards another item
            </summary>
        </member>
        <member name="T:NReco.CF.Taste.Similarity.Precompute.SimilarItems">
            <summary>
            Compact representation of all similar items for an item
            </summary>
        </member>
    </members>
</doc>
